<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Copper Rock Golf Course</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Fonts from original Shell.html -->
    <link href="https://fonts.googleapis.com/css2?family=Helvetica+Neue&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000000; /* Set background to black */
            touch-action: none; /* Disable default touch behaviors */
            user-select: none; /* Disable text selection */
            -webkit-user-select: none; /* Safari specific styling */
        }

        /* Hart Bench Ranch UI Font Override */
        .menu-container, .details-box, .details-content, .details-inner {
            font-family: 'Helvetica Neue', Arial, sans-serif;
        }
        #vignette {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: linear-gradient(to top, black 0%, transparent 12%);
            mix-blend-mode: multiply;
        }
        /* TapDot 2D label overlay - Apple Maps style */
        #tapdot-labels-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 7;  /* above vignette (no z-index), below menu (10) so label visible in center */
        }
        #tap-focus-feedback {
            position: absolute;
            left: 0;
            top: 0;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            opacity: 0;
            pointer-events: none;
            z-index: 8;
            border: 1.5px solid rgba(255, 255, 255, 0.5);
            background: transparent;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.17);
        }
        .tapdot-label-bubble {
            position: absolute;
            transform: translate(-50%, -100%);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 8px 14px 12px;
            font-family: 'Helvetica Neue', Arial, sans-serif;
            font-size: 13px;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.95);
            white-space: nowrap;
            box-sizing: border-box;
            opacity: 0;  /* JS sets opacity via style; keep 0 as fallback until positioned */
            width: fit-content;
            min-width: 0;
            overflow: visible;
            background: rgba(255, 255, 255, 0.25);
            -webkit-backdrop-filter: blur(20px);
            backdrop-filter: blur(20px);
            -webkit-mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 140 47' preserveAspectRatio='none'%3E%3Cpath d='M 21 0 L 119 0 Q 140 0 140 21 Q 140 42 119 42 L 74 42 L 70 47 L 66 42 L 21 42 Q 0 42 0 21 Q 0 0 21 0 Z' fill='white'/%3E%3C/svg%3E");
            mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 140 47' preserveAspectRatio='none'%3E%3Cpath d='M 21 0 L 119 0 Q 140 0 140 21 Q 140 42 119 42 L 74 42 L 70 47 L 66 42 L 21 42 Q 0 42 0 21 Q 0 0 21 0 Z' fill='white'/%3E%3C/svg%3E");
            -webkit-mask-size: 100% 100%;
            mask-size: 100% 100%;
            -webkit-mask-position: 0 0;
            mask-position: 0 0;
            -webkit-mask-repeat: no-repeat;
            mask-repeat: no-repeat;
        }
        .tapdot-label-bubble .tapdot-label-bg {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        .tapdot-label-bubble .tapdot-label-bg path {
            fill: none;
        }
        .tapdot-label-bubble .tapdot-label-text {
            position: relative;
            z-index: 1;
            flex-shrink: 0;
        }
        /* Developer mode controls */
        #developerControls {
            display: none;
            position: absolute;
            bottom: 20px;
            left: 20px;
        }
        #developerControls button {
            margin-right: 10px;
            padding: 10px;
        }
        
        /* Compass Button - Commented out for later use */
        /*
        #menuButton {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid #333;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        #compassArrow {
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-bottom: 20px solid #e74c3c;
            transform-origin: center bottom;
            transition: transform 0.1s ease-out;
            position: relative;
        }
        
        #compassArrow::after {
            content: '';
            position: absolute;
            bottom: -22px;
            left: -4px;
            width: 0;
            height: 0;
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-bottom: 8px solid #c0392b;
        }
        */

        /* Hart Bench Ranch UI Styles - Ported with Extreme Care */
        
        /* Prevent text selection and highlight */
        div, p, h1, h2, h3, h4, h5, h6, span {
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            -moz-user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }

        img {
            user-drag: none;
            -webkit-user-drag: none;
        }

        /* Invisible overlay when details are open */
        #overlay-ui {
            position: absolute;
            top: 0; 
            left: 0; 
            right: 0; 
            bottom: 0;
            z-index: 8; 
            background: transparent;
            display: none; 
        }
        #overlay-ui.active {
            display: block;
        }

        /* Golden ratio: φ ≈ 1.618; short = 38.2%, long = 61.8% */
        :root {
            --phi: 1.618033988749895;
            --menu-short: 0.382;  /* existing area (2 buttons) */
            --menu-long: 0.618;   /* hole carousel area */
        }

        /* Parent Menu (default base values) - golden ratio layout */
        .menu-container {
            display: flex;
            /* Total content: existing (92px) + hole (149px) = 241px; + padding = 255px */
            width: fit-content;
            min-height: 59px;
            padding: 7px;
            justify-content: flex-start;
            align-items: center;
            gap: 0px;
            border-radius: 30px;
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 10;
            background: rgba(128, 128, 128, 0.30);
            -webkit-backdrop-filter: blur(50px);
            backdrop-filter: blur(50px);
            -webkit-transform-origin: left bottom;
            transform-origin: left bottom; /* Will use this when scaling */
            box-sizing: border-box;
            -webkit-box-sizing: border-box;
            -moz-box-sizing: border-box;
        }

        .menu-container::before {
            content: "";
            position: absolute;
            top: 0; 
            left: 0; 
            right: 0; 
            bottom: 0;
            border-radius: inherit;
            background: linear-gradient(145deg, rgba(255,255,255,0.4) 0%, rgba(255,255,255,0) 41%, rgba(255,255,255,0) 57%, rgba(255,255,255,0.4) 100%);
            -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask-composite: exclude;
            padding: 1.4px;
            pointer-events: none;
        }

        .menu-button {
            flex: 0 0 45px;
            width: 45px;
            height: 45px;
            position: relative;
            display: inline-flex;
            justify-content: center;
            align-items: center;
            border-radius: 23.5px;
            cursor: pointer;
            overflow: hidden;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            box-sizing: border-box;
            -webkit-box-sizing: border-box;
            -moz-box-sizing: border-box;
        }

        .menu-button img {
            width: 21px;
            height: 21px;
            position: relative;
            z-index: 1;
            -webkit-transform: scale(1);
            transform: scale(1);
            pointer-events: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* Hover circle for devices with actual hover capabilities */
        @media (hover:hover) {
            .menu-button:hover::before {
                content: "";
                position: absolute;
                inset: 0;
                border-radius: 50%;
                background: rgba(255,255,255,0.15);
                -webkit-transform: scale(1);
                transform: scale(1);
                -webkit-transition: -webkit-transform 0.3s ease, opacity 0.3s ease;
                transition: transform 0.3s ease, opacity 0.3s ease;
                opacity: 1;
                z-index: 0;
            }
        }

        /* For touch devices, we'll use a class "active" added via JS to simulate the hover effect */
        .menu-button::before {
            content: "";
            position: absolute;
            inset: 0;
            border-radius: 50%;
            background: rgba(255,255,255,0.15);
            -webkit-transform: scale(0);
            transform: scale(0);
            opacity: 0;
            z-index: 0;
            -webkit-transition: -webkit-transform 0.3s ease, opacity 0.3s ease;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        .menu-button.active::before {
            -webkit-transform: scale(1);
            transform: scale(1);
            opacity: 1;
        }

        #compassButton {
            margin-left: 0px;
            margin-right: 10px;
        }

        #recordButton {
            margin-left: 0px;
            margin-right: 10px;
        }
        #recordButton svg {
            color: #e74c3c;
        }

        .hole-carousel {
            flex: 0 0 149px;  /* long part of golden ratio (61.8% of 241px) */
            min-width: 0;
            height: 45px;
            margin-left: 0px;
            border-radius: 23.5px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 2px;
            padding: 0;
            position: relative;
            background: rgba(255, 255, 255, 0.05);
            overflow: hidden;
            box-sizing: border-box;
            -webkit-box-sizing: border-box;
            -moz-box-sizing: border-box;
        }

        .hole-carousel::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: inherit;
            background: linear-gradient(145deg, rgba(255,255,255,0.28) 0%, rgba(255,255,255,0) 41%, rgba(255,255,255,0) 57%, rgba(255,255,255,0.28) 100%);
            -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask-composite: exclude;
            padding: 1.1px;
            pointer-events: none;
            z-index: 0;
        }

        .hole-nav-button,
        .hole-label-button {
            border: 0;
            background: transparent;
            color: rgba(255, 255, 255, 0.94);
            font-family: 'Helvetica Neue', Arial, sans-serif;
            position: relative;
            z-index: 1;
            border-radius: 18px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
            -webkit-box-sizing: border-box;
            -moz-box-sizing: border-box;
        }
        .hole-nav-button:disabled,
        .hole-label-button:disabled {
            opacity: 0.4;
            cursor: default;
            pointer-events: none;
        }

        .hole-nav-button {
            width: 45px;
            height: 45px;
            flex: 0 0 auto;
            padding: 0;
            border-radius: 22.5px;
        }

        .hole-nav-button svg {
            width: 21px;
            height: 21px;
            display: block;
            pointer-events: none;
        }

        .hole-label-button {
            min-width: 52px;
            height: 34px;
            padding: 0 6px;
            font-size: 14px;
            font-weight: 500;
            letter-spacing: 0.2px;
            line-height: 1;
            white-space: nowrap;
        }

        .hole-nav-button::before,
        .hole-label-button::before {
            content: "";
            position: absolute;
            inset: 0;
            border-radius: inherit;
            background: rgba(255,255,255,0.15);
            -webkit-transform: scale(0);
            transform: scale(0);
            opacity: 0;
            z-index: 0;
            -webkit-transition: -webkit-transform 0.3s ease, opacity 0.3s ease;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        /* Keep hole-nav hover effect at original 34×34 size */
        .hole-nav-button::before {
            inset: auto;
            width: 34px;
            height: 34px;
            left: 50%;
            top: 50%;
            margin-left: -17px;
            margin-top: -17px;
            border-radius: 17px;
        }

        @media (hover:hover) {
            .hole-nav-button:hover::before {
                -webkit-transform: scale(1);
                transform: scale(1);
                opacity: 1;
            }
        }
        /* No hover effect on hole-label-button (Hole 1 title) */

        .hole-nav-button.active::before {
            -webkit-transform: scale(1);
            transform: scale(1);
            opacity: 1;
        }

        .hole-label-button span {
            position: relative;
            z-index: 1;
        }

        /* Details Box (default base values) */
        .details-box {
            position: absolute;
            z-index: 9; 
            top: 60px;
            left: 20px;
            right: 20px;
            bottom: 60px;
            border-radius: 30px;
            background: rgba(128,128,128,0.30);
            -webkit-backdrop-filter: blur(50px);
            backdrop-filter: blur(50px);
            display: flex;
            flex-direction: column;
            opacity: 0;
            -webkit-transform: scale(0.95);
            transform: scale(0.95);
            pointer-events: none;
            -webkit-transition: opacity 0.3s ease, -webkit-transform 0.3s ease;
            -webkit-transition: opacity 0.3s ease, transform 0.3s ease;
            transition: opacity 0.3s ease, transform 0.3s ease;
            overflow: hidden;
        }

        .details-box::before {
            content: "";
            position: absolute;
            top: 0; 
            left: 0; 
            right: 0; 
            bottom: 0;
            border-radius: inherit;
            background: linear-gradient(145deg, rgba(255,255,255,0.4) 0%, rgba(255,255,255,0) 41%, rgba(255,255,255,0) 57%, rgba(255,255,255,0.4) 100%);
            -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask-composite: exclude;
            padding: 1.4px;
            pointer-events: none;
        }

        .details-box.show {
            opacity: 1;
            -webkit-transform: scale(1);
            transform: scale(1);
            pointer-events: auto;
        }

        /* Ensure no native scrollbar: use overflow:scroll and hide scrollbar completely */
        .details-content {
            flex: 1;
            margin: 4px; 
            overflow-y: scroll;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
        }

        .details-content::-webkit-scrollbar {
            width: 0;
            height: 0; /* Ensure no visible scrollbar on iOS */
        }

        .details-inner {
            padding: 55px 30px; 
        }

        /* Custom scrollbar */
        .custom-scrollbar {
            position: absolute;
            right: 3px; 
            top: 0; 
            bottom: 0; 
            width: 5px;
            background: transparent;
            display: flex;
            justify-content: center;
            opacity: 0; 
            -webkit-transition: opacity 0.2s ease-in-out;
            transition: opacity 0.2s ease-in-out;
        }

        .custom-scroll-thumb {
            position: relative;
            width: 2px;
            background: rgba(255,255,255,0.8);
            border-radius: 4px;
            -webkit-transition: width 0.2s ease, background 0.2s ease;
            transition: width 0.2s ease, background 0.2s ease;
            pointer-events: auto;
            cursor: grab;
            -webkit-transform: translateY(0);
            transform: translateY(0);
        }

        .custom-scrollbar:hover .custom-scroll-thumb,
        .custom-scroll-thumb:active {
            width: 5px; 
            background: rgba(255,255,255,1);
        }

        .details-content h1 {
            font-size: 30px;
            font-weight: 500;
            line-height: 1.3;
            margin-bottom: 16px;
            color: white;
        }

        .details-content p {
            font-size: 17px;
            font-weight: 400;
            line-height: 1.5;
            letter-spacing: 0.2px;
            color: rgba(255, 255, 255, 0.9);
            margin-bottom: 100px;
        }

        .legal-disclaimer {
            font-size: 14px;
            line-height: 1.3;
            color: rgba(255,255,255,0.7);
            margin-bottom: 20px;
        }

        /* Keyframes for the spring-like animations */
        @-webkit-keyframes shrinkIcon {
            0% {
                -webkit-transform: scale(1);
                transform: scale(1);
            }
            100% {
                -webkit-transform: scale(0.7);
                transform: scale(0.7);
            }
        }
        @keyframes shrinkIcon {
            0% {
                -webkit-transform: scale(1);
                transform: scale(1);
            }
            100% {
                -webkit-transform: scale(0.7);
                transform: scale(0.7);
            }
        }

        @-webkit-keyframes expandIcon {
            0% {
                -webkit-transform: scale(0.7);
                transform: scale(0.7);
            }
            60% {
                -webkit-transform: scale(1.05);
                transform: scale(1.05);
            }
            100% {
                -webkit-transform: scale(1);
                transform: scale(1);
            }
        }
        @keyframes expandIcon {
            0% {
                -webkit-transform: scale(0.7);
                transform: scale(0.7);
            }
            60% {
                -webkit-transform: scale(1.05);
                transform: scale(1.05);
            }
            100% {
                -webkit-transform: scale(1);
                transform: scale(1);
            }
        }
        
        /* Add this below your existing styles */
        .touch-scrollbars {
            scrollbar-width: auto !important; /* For Firefox */
        }
        .touch-scrollbars::-webkit-scrollbar {
            width: 8px; /* or whatever width you like for native scrollbar on iOS/Android */
            height: 8px;
        }

        /* Fullscreen button moved to details box upper right */
        .details-fullscreen-button {
            position: absolute;
            top: 7px;
            right: 7px;
            width: 45px;
            height: 45px;
            display: inline-flex;
            justify-content: center;
            align-items: center;
            border-radius: 23.5px;
            cursor: pointer;
            overflow: hidden;
            z-index: 11;
            box-sizing: border-box;
            -webkit-box-sizing: border-box;
            -moz-box-sizing: border-box;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        .details-fullscreen-button img {
            width: 21px;
            height: 21px;
            position: relative;
            z-index: 1;
            -webkit-transform: scale(1);
            transform: scale(1);
            pointer-events: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* Hover effects for fullscreen button in details box */
        @media (hover:hover) {
            .details-fullscreen-button:hover::before {
                content: "";
                position: absolute;
                inset: 0;
                border-radius: 50%;
                background: rgba(255,255,255,0.15);
                -webkit-transform: scale(1);
                transform: scale(1);
                -webkit-transition: -webkit-transform 0.3s ease, opacity 0.3s ease;
                transition: transform 0.3s ease, opacity 0.3s ease;
                opacity: 1;
                z-index: 0;
            }
        }

        .details-fullscreen-button::before {
            content: "";
            position: absolute;
            inset: 0;
            border-radius: 50%;
            background: rgba(255,255,255,0.15);
            -webkit-transform: scale(0);
            transform: scale(0);
            opacity: 0;
            z-index: 0;
            -webkit-transition: -webkit-transform 0.3s ease, opacity 0.3s ease;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        .details-fullscreen-button.active::before {
            -webkit-transform: scale(1);
            transform: scale(1);
            opacity: 1;
        }

        /* TapDot popup – centered, dimensions based on first photo, caption at bottom */
        .tapdot-popup {
            position: fixed;
            z-index: 11;
            left: 50%;
            top: 50%;
            -webkit-transform: translate(-50%, -50%) scale(0.95);
            transform: translate(-50%, -50%) scale(0.95);
            max-width: calc(100vw - 48px);
            max-height: calc(100vh - 80px);
            border-radius: 30px;
            background: #000;
            display: flex;
            flex-direction: column;
            opacity: 0;
            pointer-events: none;
            -webkit-transition: opacity 0.3s ease, -webkit-transform 0.3s ease;
            transition: opacity 0.3s ease, transform 0.3s ease;
            overflow: hidden;
        }
        .tapdot-popup::before {
            content: "";
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            border-radius: inherit;
            background: linear-gradient(145deg, rgba(255,255,255,0.08) 0%, rgba(255,255,255,0) 41%, rgba(255,255,255,0) 57%, rgba(255,255,255,0.08) 100%);
            -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask-composite: exclude;
            padding: 1.4px;
            pointer-events: none;
        }
        .tapdot-popup.show {
            opacity: 1;
            -webkit-transform: translate(-50%, -50%) scale(1);
            transform: translate(-50%, -50%) scale(1);
            pointer-events: auto;
        }
        /* Photo area: no scroll; image contained so full photo always visible, black letterboxing */
        .tapdot-popup .tapdot-popup-content {
            flex: 1;
            margin: 0;
            min-height: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000;
        }
        .tapdot-popup .tapdot-photo-wrap {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            border-radius: 0;
            margin: 0;
            background: #000;
            position: relative;
        }
        .tapdot-photo-spinner {
            position: absolute;
            width: 28px;
            height: 28px;
            border: 2px solid rgba(255, 255, 255, 0.15);
            border-top-color: rgba(255, 255, 255, 0.85);
            border-radius: 50%;
            -webkit-animation: tapdot-spinner-spin 0.7s linear infinite;
            animation: tapdot-spinner-spin 0.7s linear infinite;
            z-index: 1;
            display: none;
        }
        .tapdot-photo-spinner.visible {
            display: block;
        }
        @-webkit-keyframes tapdot-spinner-spin {
            to { -webkit-transform: rotate(360deg); transform: rotate(360deg); }
        }
        @keyframes tapdot-spinner-spin {
            to { -webkit-transform: rotate(360deg); transform: rotate(360deg); }
        }
        .tapdot-popup .tapdot-photo {
            max-width: 100%;
            max-height: 100%;
            width: auto;
            cursor: pointer;
            height: auto;
            object-fit: contain;
            display: block;
            -webkit-transition: opacity 0.3s ease;
            transition: opacity 0.3s ease;
            /* Slight scale to eliminate sub-pixel black borders */
            -webkit-transform: scale(1.02);
            transform: scale(1.02);
        }
        .tapdot-popup .tapdot-photo.fade {
            opacity: 0;
        }
        /* Carousel arrows: left/right edges of image, vertically centered */
        .tapdot-carousel-nav {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 16px;
            z-index: 2;
            pointer-events: none;
        }
        .tapdot-carousel-nav.visible {
            pointer-events: none;
        }
        .tapdot-carousel-nav.visible .tapdot-carousel-arrow {
            pointer-events: auto;
        }
        .tapdot-carousel-nav.hidden { display: none !important; }
        .tapdot-carousel-arrow {
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: white;
            opacity: 0.5;
            -webkit-transition: opacity 0.2s ease;
            transition: opacity 0.2s ease;
        }
        .tapdot-carousel-arrow:hover { opacity: 1; }
        .tapdot-carousel-arrow svg {
            width: 22px;
            height: 22px;
            stroke-width: 2;
        }
        /* Dots: underneath caption, left-aligned with caption */
        .tapdot-carousel-dots {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .tapdot-carousel-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.5);
            cursor: pointer;
            -webkit-transition: background 0.2s ease;
            transition: background 0.2s ease;
        }
        .tapdot-carousel-dot:hover,
        .tapdot-carousel-dot.active {
            background: rgba(255, 255, 255, 1);
        }
        /* Caption overlay: fixed at bottom of popup, gradient + text + dots */
        .tapdot-popup .tapdot-caption-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 200px;
            z-index: 2;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            pointer-events: none;
        }
        .tapdot-popup .tapdot-caption-overlay .tapdot-caption-wrap {
            pointer-events: auto;
        }
        .tapdot-popup .tapdot-caption-gradient {
            position: absolute;
            inset: 0;
            background: linear-gradient(to top, rgba(0,0,0,0.92) 0%, rgba(0,0,0,0.5) 28%, rgba(0,0,0,0.12) 55%, transparent 100%);
            z-index: 0;
        }
        .tapdot-popup .tapdot-caption-wrap {
            position: relative;
            z-index: 1;
            padding: 0 28px 28px;
        }
        .tapdot-popup .tapdot-caption {
            font-size: 17px;
            font-weight: 400;
            line-height: 1.5;
            letter-spacing: 0.2px;
            color: rgba(255, 255, 255, 0.95);
            margin: 0 0 8px;
            font-family: 'Helvetica Neue', Arial, sans-serif;
        }
        .tapdot-popup .tapdot-carousel-dots-wrap {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .tapdot-popup-content { position: relative; }
        .tapdot-popup-close {
            position: absolute;
            top: 7px;
            right: 7px;
            width: 45px;
            height: 45px;
            display: inline-flex;
            justify-content: center;
            align-items: center;
            border-radius: 23.5px;
            cursor: pointer;
            z-index: 11;
            background: transparent;
            border: none;
            overflow: hidden;
            -webkit-user-select: none;
            user-select: none;
        }
        .tapdot-popup-close::before {
            content: "";
            position: absolute;
            inset: 0;
            border-radius: 50%;
            background: rgba(255,255,255,0.15);
            -webkit-transform: scale(0);
            transform: scale(0);
            opacity: 0;
            z-index: 0;
            -webkit-transition: -webkit-transform 0.3s ease, opacity 0.3s ease;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }
        @media (hover: hover) {
            .tapdot-popup-close:hover::before {
                -webkit-transform: scale(1);
                transform: scale(1);
                opacity: 1;
            }
        }
        .tapdot-popup-close.active::before {
            -webkit-transform: scale(1);
            transform: scale(1);
            opacity: 1;
        }
        .tapdot-popup-close img {
            width: 21px;
            height: 21px;
            position: relative;
            z-index: 1;
            pointer-events: none;
            filter: brightness(0) invert(1);
        }

        /* Compass icon in parent menu */
        #compassIcon {
            width: 21px;
            height: 21px;
            position: relative;
            z-index: 1;
            transform-origin: center center; /* Center rotation point */
            /* No transition on transform to allow real-time rotation */
            pointer-events: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* Lot editor controls */
        .lot-editor-toggle-wrap {
            position: absolute;
            right: 20px;
            bottom: 20px;
            z-index: 12;
        }
        .lot-editor-toggle {
            min-width: 126px;
            height: 45px;
            border-radius: 23.5px;
            border: 0;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 0 16px;
            cursor: pointer;
            color: rgba(255, 255, 255, 0.92);
            background: rgba(128, 128, 128, 0.32);
            -webkit-backdrop-filter: blur(50px);
            backdrop-filter: blur(50px);
            font: 500 13px/1 'Helvetica Neue', Arial, sans-serif;
            letter-spacing: 0.2px;
            position: relative;
            overflow: hidden;
        }
        .lot-editor-toggle::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: inherit;
            background: linear-gradient(145deg, rgba(255,255,255,0.4) 0%, rgba(255,255,255,0) 41%, rgba(255,255,255,0) 57%, rgba(255,255,255,0.4) 100%);
            -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask-composite: exclude;
            padding: 1.4px;
            pointer-events: none;
        }
        .lot-editor-toggle svg,
        .lot-editor-toggle span {
            position: relative;
            z-index: 1;
        }
        .lot-editor-toggle svg {
            width: 16px;
            height: 16px;
            opacity: 0.9;
        }
        .lot-editor-toggle.active {
            color: #fff;
            background: rgba(191, 40, 27, 0.45);
        }
        .lot-editor-panel {
            position: absolute;
            right: 20px;
            bottom: 76px;
            z-index: 12;
            width: 248px;
            border-radius: 20px;
            background: rgba(32, 32, 32, 0.5);
            -webkit-backdrop-filter: blur(45px);
            backdrop-filter: blur(45px);
            color: rgba(255, 255, 255, 0.95);
            font-family: 'Helvetica Neue', Arial, sans-serif;
            padding: 14px 14px 12px;
            box-sizing: border-box;
            opacity: 0;
            transform: translateY(8px) scale(0.98);
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease;
        }
        .lot-editor-panel::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: inherit;
            background: linear-gradient(145deg, rgba(255,255,255,0.24) 0%, rgba(255,255,255,0) 41%, rgba(255,255,255,0) 57%, rgba(255,255,255,0.24) 100%);
            -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask-composite: exclude;
            padding: 1.2px;
            pointer-events: none;
        }
        .lot-editor-panel.active {
            opacity: 1;
            transform: translateY(0) scale(1);
            pointer-events: auto;
        }
        .lot-editor-panel > * {
            position: relative;
            z-index: 1;
        }
        .lot-editor-title {
            font-size: 13px;
            font-weight: 600;
            letter-spacing: 0.2px;
            margin-bottom: 7px;
        }
        .lot-editor-status {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.78);
            margin-bottom: 10px;
            line-height: 1.35;
            min-height: 32px;
        }
        .lot-editor-vertex {
            font-size: 12px;
            margin-bottom: 10px;
            color: rgba(255, 255, 255, 0.88);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .lot-editor-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
        }
        .lot-editor-field {
            display: flex;
            flex-direction: column;
            gap: 5px;
            min-width: 0;
        }
        .lot-editor-field label {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.74);
        }
        .lot-editor-field input {
            width: 100%;
            border: 1px solid rgba(255, 255, 255, 0.18);
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.32);
            color: #fff;
            font: 500 12px/1 'Helvetica Neue', Arial, sans-serif;
            padding: 8px 8px;
            box-sizing: border-box;
            outline: none;
        }
        .lot-editor-field input:focus {
            border-color: rgba(255, 255, 255, 0.42);
        }
        .lot-editor-field input:disabled {
            opacity: 0.45;
            cursor: not-allowed;
        }
        .lot-editor-actions {
            margin-top: 11px;
            display: flex;
            gap: 8px;
        }
        .lot-editor-action-btn {
            flex: 1;
            border: 1px solid rgba(255, 255, 255, 0.18);
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.34);
            color: #fff;
            font: 500 12px/1 'Helvetica Neue', Arial, sans-serif;
            padding: 9px 8px;
            cursor: pointer;
            transition: border-color 0.2s ease, background 0.2s ease;
        }
        .lot-editor-action-btn:hover {
            border-color: rgba(255, 255, 255, 0.38);
            background: rgba(191, 40, 27, 0.38);
        }
        .editor-toggles-wrap {
            position: absolute;
            top: 12px;
            right: 12px;
            z-index: 12;
            display: flex;
            gap: 8px;
        }
        .animation-editor-toggle-wrap {
            margin: 0;
        }
        .splat-editor-toggle-wrap {
            margin: 0;
        }
        .lot-editor-toggle-wrap {
            margin: 0;
        }
        .editor-toggles-wrap .lot-editor-toggle-wrap {
            position: static;
            right: auto;
            bottom: auto;
        }
        .animation-editor-toggle-icon-only {
            padding: 0;
            min-width: 40px;
        }
        .animation-editor-toggle-icon-only svg {
            width: 20px;
            height: 20px;
        }
        .animation-editor-toggle-icon-only span {
            display: none;
        }
        .animation-editor-panel {
            left: auto;
            right: 12px;
            top: 66px;
            bottom: auto;
            width: 260px;
            max-width: min(260px, calc(100vw - 24px));
        }
        .animation-editor-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 6px;
            margin-bottom: 2px;
        }
        .animation-editor-header .lot-editor-title {
            margin-bottom: 0;
            font-size: 13px;
        }
        .animation-editor-close {
            width: 24px;
            min-width: 24px;
            height: 24px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            background: rgba(0, 0, 0, 0.3);
            color: rgba(255, 255, 255, 0.9);
            font: 500 14px/1 sans-serif;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            padding: 0;
            transition: border-color 0.2s ease, background 0.2s ease;
        }
        .animation-editor-close:hover {
            border-color: rgba(255, 255, 255, 0.42);
            background: rgba(191, 40, 27, 0.34);
        }
        .animation-editor-panel .lot-editor-status {
            min-height: 0;
            margin-bottom: 4px;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.7);
        }
        .animation-editor-summary {
            margin: 0 0 4px;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.6);
            line-height: 1.2;
        }
        .animation-checkpoint-strip {
            display: flex;
            gap: 4px;
            overflow-x: auto;
            margin: 0 0 6px;
            padding: 0 0 4px;
            scrollbar-width: thin;
            align-items: center;
        }
        .animation-checkpoint-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            flex-shrink: 0;
        }
        .animation-checkpoint-hover-actions {
            display: flex;
            gap: 2px;
            margin-top: 4px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.15s ease;
            justify-content: center;
        }
        .animation-checkpoint-item:hover .animation-checkpoint-hover-actions {
            opacity: 1;
            pointer-events: auto;
        }
        .animation-checkpoint-hover-actions button {
            width: 24px;
            height: 24px;
            padding: 0;
            font-size: 11px;
            font-weight: 500;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.5);
            color: rgba(255, 255, 255, 0.9);
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: border-color 0.15s ease, background 0.15s ease;
        }
        .animation-checkpoint-hover-actions button:hover {
            background: rgba(255, 255, 255, 0.12);
            border-color: rgba(255, 255, 255, 0.4);
        }
        .animation-checkpoint-hover-actions .animation-checkpoint-delete-btn {
            color: #e85a4f;
        }
        .animation-checkpoint-hover-actions .animation-checkpoint-delete-btn:hover {
            background: rgba(232, 90, 79, 0.35);
        }
        .animation-checkpoint-hover-actions .animation-checkpoint-overwrite-btn:hover {
            background: rgba(76, 175, 80, 0.25);
        }
        .animation-checkpoint-hover-actions button svg {
            width: 12px;
            height: 12px;
        }
        .animation-checkpoint-strip::-webkit-scrollbar {
            height: 6px;
        }
        .animation-checkpoint-strip::-webkit-scrollbar-thumb {
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.22);
        }
        .animation-checkpoint-pill {
            width: 32px;
            min-width: 32px;
            height: 32px;
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.3);
            color: rgba(255, 255, 255, 0.92);
            font: 500 11px/1 'Helvetica Neue', Arial, sans-serif;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            transition: border-color 0.2s ease, background 0.2s ease;
            position: relative;
        }
        .animation-checkpoint-pill .animation-checkpoint-pill-label {
            transition: opacity 0.15s ease;
        }
        .animation-checkpoint-pill:hover {
            border-color: rgba(255, 255, 255, 0.42);
            background: rgba(0, 0, 0, 0.5);
        }
        .animation-checkpoint-pill.active {
            border-color: rgba(255, 255, 255, 0.5);
            background: rgba(191, 40, 27, 0.52);
        }
        .animation-checkpoint-pill.playing {
            box-shadow: 0 0 0 2px rgba(191, 40, 27, 0.26);
        }
        .animation-editor-actions {
            margin-top: 4px;
            display: flex;
            gap: 4px;
        }
        .animation-editor-actions .lot-editor-action-btn {
            margin-top: 0;
            padding: 8px;
            min-width: 0;
            flex: 1;
        }
        .animation-editor-btn-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        .animation-editor-btn-icon svg {
            width: 18px;
            height: 18px;
        }
        .splat-editor-panel {
            top: 66px;
            width: 260px;
            max-width: min(260px, calc(100vw - 24px));
        }
        .splat-editor-grid {
            grid-template-columns: 1fr 1fr 1fr;
        }
        .splat-editor-scale-field {
            grid-column: 1 / -1;
        }
        .splat-editor-actions {
            margin-top: 8px;
        }
        .lot-midpoint-layer {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 11;
        }
        .lot-midpoint-plus {
            position: absolute;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 0;
            color: #fff;
            font: 500 20px/30px 'Helvetica Neue', Arial, sans-serif;
            text-align: center;
            padding: 0;
            background: rgba(45, 45, 45, 0.75);
            -webkit-backdrop-filter: blur(28px);
            backdrop-filter: blur(28px);
            box-shadow: 0 3px 16px rgba(0, 0, 0, 0.22);
            pointer-events: auto;
            cursor: pointer;
            transform: translate(-50%, -50%);
        }
        .lot-midpoint-plus:hover {
            background: rgba(191, 40, 27, 0.85);
        }
        @media (max-width: 720px) {
            .editor-toggles-wrap {
                top: 12px;
                right: 12px;
            }
            .animation-editor-panel {
                left: auto;
                right: 12px;
                top: 66px;
                bottom: auto;
                width: min(260px, calc(100vw - 24px));
            }
            .lot-editor-toggle-wrap {
                right: 12px;
                bottom: 12px;
            }
            .lot-editor-panel {
                right: 12px;
                bottom: 66px;
                width: min(230px, calc(100vw - 24px));
            }
        }

        /* Hide all UI during recording for clean capture */
        body.recording-mode .menu-container,
        body.recording-mode #detailsBox,
        body.recording-mode #overlay-ui,
        body.recording-mode #tapdot-labels-layer,
        body.recording-mode .editor-toggles-wrap,
        body.recording-mode #developerControls,
        body.recording-mode #vignette,
        body.recording-mode #tap-focus-feedback,
        body.recording-mode .tapdot-popup {
            visibility: hidden !important;
            pointer-events: none !important;
        }
    </style>
</head>
<body>
    <div id="vignette"></div>
    <div id="tapdot-labels-layer"></div>
    <div id="tap-focus-feedback" aria-hidden="true"></div>
    <div id="overlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; align-items: center; justify-content: center; color: white; font-size: 24px; font-family: Arial, sans-serif;">Lot #1</div>

    <!-- Compass temporarily hidden - will be used later for UI functionality -->
    <!-- <div id="menuButton">
        <div id="compassArrow"></div>
    </div> -->

    <!-- Hart Bench Ranch UI - Ported with Extreme Care -->
    
    <!-- Invisible overlay to detect outside clicks when details are open -->
    <div id="overlay-ui"></div>

    <div class="menu-container" id="menuContainer">
        <div id="detailsButton" class="menu-button">
            <img src="https://raw.githubusercontent.com/HansenHomeAI/FigmaSVGButtons/main/DetailsIconDefault.svg" alt="Details" draggable="false">
        </div>
        <div id="compassButton" class="menu-button">
            <img id="compassIcon" src="https://raw.githubusercontent.com/HansenHomeAI/FigmaSVGButtons/main/NorthOutline.svg" alt="Compass" draggable="false">
        </div>
        <div id="recordButton" class="menu-button" title="Record 20s of path animation">
            <svg viewBox="0 0 24 24" fill="currentColor" width="21" height="21" aria-hidden="true"><circle cx="12" cy="12" r="6"/></svg>
        </div>
        <div id="holeCarousel" class="hole-carousel" role="group" aria-label="Hole selector">
            <button id="holePrevButton" class="hole-nav-button" type="button" aria-label="Previous hole">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                    <path d="M14.5 18.5L8 12l6.5-6.5"></path>
                </svg>
            </button>
            <button id="holeLabelButton" class="hole-label-button" type="button" aria-label="Hole 15">
                <span id="holeLabelText">Hole 15</span>
            </button>
            <button id="holeNextButton" class="hole-nav-button" type="button" aria-label="Next hole">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                    <path d="M9.5 5.5L16 12l-6.5 6.5"></path>
                </svg>
            </button>
        </div>
    </div>

    <div class="editor-toggles-wrap" id="editorTogglesWrap">
    <div class="splat-editor-toggle-wrap" id="splatEditorToggleWrap">
        <button id="splatEditorToggle" class="lot-editor-toggle animation-editor-toggle-icon-only" type="button" aria-pressed="false" aria-label="Toggle splat transform editor" title="Splat position & rotation">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2L2 7l10 5 10-5-10-5z"/><path d="M2 17l10 5 10-5"/></svg>
        </button>
    </div>
    <div class="lot-editor-toggle-wrap" id="lotEditorToggleWrap">
        <button id="lotEditorToggle" class="lot-editor-toggle animation-editor-toggle-icon-only" type="button" aria-pressed="false" aria-label="Toggle lot edit mode" title="Edit lots / tap dot positions">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                <path d="M3 17.5V21h3.5L17.2 10.3l-3.5-3.5L3 17.5z"></path>
                <path d="M12.4 7.6l3.5 3.5"></path>
                <path d="M18 6l1.2-1.2a1.8 1.8 0 1 1 2.5 2.5L20.5 8.5"></path>
            </svg>
        </button>
    </div>
    <div class="animation-editor-toggle-wrap" id="animationEditorToggleWrap">
        <button id="animationEditorToggle" class="lot-editor-toggle animation-editor-toggle-icon-only" type="button" aria-pressed="false" aria-label="Toggle camera path editor">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                <path d="M4 18.5a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5z"></path>
                <path d="M20 10.5a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5z"></path>
                <path d="M12 21a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5z"></path>
                <path d="M6.2 14.2 17.7 9"></path>
                <path d="M10.4 18.3 6.3 16"></path>
            </svg>
        </button>
    </div>
    <div id="animationEditorPanel" class="lot-editor-panel animation-editor-panel" aria-live="polite">
        <div class="animation-editor-header">
            <div class="lot-editor-title">Path</div>
            <button id="animationEditorCloseButton" class="animation-editor-close" type="button" aria-label="Close">×</button>
        </div>
        <div id="animationEditorStatus" class="lot-editor-status animation-editor-status-compact"></div>
        <div id="animationEditorSummary" class="animation-editor-summary"></div>
        <div id="animationCheckpointStrip" class="animation-checkpoint-strip" aria-label="Camera checkpoints"></div>
        <div class="animation-editor-actions">
            <button id="animationCaptureCheckpointButton" type="button" class="lot-editor-action-btn animation-editor-btn-icon" aria-label="Capture checkpoint" title="Capture (inserts after selected)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="4" fill="currentColor" stroke="none"/></svg>
            </button>
            <button id="animationPlayToggleButton" type="button" class="lot-editor-action-btn animation-editor-btn-icon" aria-label="Play path" title="Play / Pause">
                <svg class="icon-play" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>
                <svg class="icon-pause" viewBox="0 0 24 24" fill="currentColor" style="display:none"><path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z"/></svg>
            </button>
            <button id="animationExportButton" type="button" class="lot-editor-action-btn animation-editor-btn-icon" aria-label="Copy JSON" title="Copy path JSON">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>
            </button>
        </div>
    </div>
    </div>

    <div id="splatEditorPanel" class="lot-editor-panel animation-editor-panel splat-editor-panel" aria-live="polite">
        <div class="animation-editor-header">
            <div class="lot-editor-title">Splat Transform</div>
            <button id="splatEditorCloseButton" class="animation-editor-close" type="button" aria-label="Close">×</button>
        </div>
        <div id="splatEditorStatus" class="lot-editor-status animation-editor-status-compact">Editing: Hole 15</div>
        <div class="lot-editor-grid splat-editor-grid">
            <div class="lot-editor-field">
                <label for="splatPosX">Pos X</label>
                <input id="splatPosX" type="number" step="0.001">
            </div>
            <div class="lot-editor-field">
                <label for="splatPosY">Pos Y</label>
                <input id="splatPosY" type="number" step="0.001">
            </div>
            <div class="lot-editor-field">
                <label for="splatPosZ">Pos Z</label>
                <input id="splatPosZ" type="number" step="0.001">
            </div>
            <div class="lot-editor-field">
                <label for="splatRotX">Rot X°</label>
                <input id="splatRotX" type="number" step="0.1">
            </div>
            <div class="lot-editor-field">
                <label for="splatRotY">Rot Y°</label>
                <input id="splatRotY" type="number" step="0.1">
            </div>
            <div class="lot-editor-field">
                <label for="splatRotZ">Rot Z°</label>
                <input id="splatRotZ" type="number" step="0.1">
            </div>
            <div class="lot-editor-field splat-editor-scale-field">
                <label for="splatScale">Scale</label>
                <input id="splatScale" type="number" step="0.01" min="0.01">
            </div>
        </div>
        <div class="animation-editor-actions splat-editor-actions">
            <button id="splatExportButton" type="button" class="lot-editor-action-btn animation-editor-btn-icon" aria-label="Copy splat JSON" title="Copy splat config JSON">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>
            </button>
        </div>
    </div>

    <div id="lotEditorPanel" class="lot-editor-panel animation-editor-panel" aria-live="polite">
        <div class="lot-editor-title">Lot Line Editing</div>
        <div id="lotEditorStatus" class="lot-editor-status">Enable mode, then drag vertices to adjust boundaries.</div>
        <div id="lotEditorVertexName" class="lot-editor-vertex">Vertex: none selected</div>
        <div class="lot-editor-grid">
            <div class="lot-editor-field">
                <label for="lotVertexXInput">X</label>
                <input id="lotVertexXInput" type="number" step="0.001" disabled>
            </div>
            <div class="lot-editor-field">
                <label for="lotVertexYInput">Y</label>
                <input id="lotVertexYInput" type="number" step="0.001" disabled>
            </div>
            <div class="lot-editor-field">
                <label for="lotVertexZInput">Z</label>
                <input id="lotVertexZInput" type="number" step="0.001" disabled>
            </div>
        </div>
        <div class="lot-editor-actions">
            <button id="lotCopyJsonButton" type="button" class="lot-editor-action-btn">Copy Lot JSON</button>
        </div>
    </div>
    <div id="lotMidpointLayer" class="lot-midpoint-layer"></div>

    <!-- TapDot popup: photo carousel (tap left/right to navigate), caption at bottom -->
    <div id="tapdotPopup" class="tapdot-popup">
        <button type="button" class="tapdot-popup-close" id="tapdotPopupClose" aria-label="Close">
            <img src="https://raw.githubusercontent.com/HansenHomeAI/FigmaSVGButtons/main/Close2IconDefault.svg" alt="" draggable="false">
        </button>
        <div class="tapdot-popup-content">
            <div class="tapdot-photo-wrap">
                <div id="tapdotPhotoSpinner" class="tapdot-photo-spinner" aria-hidden="true"></div>
                <img id="tapdotPopupPhoto" class="tapdot-photo" src="" alt="">
            </div>
            <div id="tapdotCarouselNav" class="tapdot-carousel-nav hidden">
                <div id="tapdotCarouselPrev" class="tapdot-carousel-arrow" aria-label="Previous photo">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                </div>
                <div id="tapdotCarouselNext" class="tapdot-carousel-arrow" aria-label="Next photo">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 18l6-6-6-6"/></svg>
                </div>
            </div>
        </div>
        <div class="tapdot-caption-overlay">
            <div class="tapdot-caption-gradient" aria-hidden="true"></div>
            <div class="tapdot-caption-wrap">
                <p id="tapdotPopupCaption" class="tapdot-caption"></p>
                <div id="tapdotCarouselDots" class="tapdot-carousel-dots-wrap"></div>
            </div>
        </div>
    </div>

    <div id="detailsBox" class="details-box">
        <!-- Fullscreen button moved to upper right corner of details box -->
        <div id="fullscreenButton" class="details-fullscreen-button">
            <img src="https://raw.githubusercontent.com/HansenHomeAI/FigmaSVGButtons/main/FullScreenIconDefault.svg" alt="Fullscreen" draggable="false">
        </div>
        <div class="details-content" id="detailsContent">
            <div class="details-inner" id="detailsInner">
                <h1>Copper Rock Golf Course</h1>
                <hr style="border:none; border-top:1px solid rgba(255,255,255,0.4); margin:15px 0;">
                <hr style="border:none; border-top:0px solid rgba(255,255,255,0.4); margin:13px 0;">

                <p>Copper Rock Golf Course is a premier championship-level golf destination set against the striking red rock cliffs and open desert vistas of Hurricane, Utah. Designed for both playability and prestige, the 18-hole layout stretches across former farmland transformed into rolling fairways, sculpted greens, and panoramic sightlines of the Pine Valley Mountains and Hurricane Cliffs.</p>
                <p>Blending wide, inviting driving corridors with thoughtfully placed hazards and elevation changes, Copper Rock delivers a refined yet challenging experience for golfers of every caliber. The course's modern clubhouse, immaculate conditioning, and sweeping Southern Utah scenery create an atmosphere that feels equal parts resort retreat and competitive venue — a place where luxury, landscape, and championship design converge.</p>

                <div class="legal-disclaimer">
                    <hr style="border:none; border-top:1px solid rgba(255,255,255,0.4); margin:30px 0;">
                    
                </div>
            </div>
        </div>
        <div class="custom-scrollbar" id="customScrollbar">
            <div class="custom-scroll-thumb" id="customThumb"></div>
        </div>
    </div>

    <!-- Developer mode controls -->
    <div id="developerControls">
        <button id="toggleSplat1">Toggle Splat 1</button>
        <button id="toggleSplat2">Toggle Splat 2</button>
    </div>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.157.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.157.0/examples/jsm/",
            "@lumaai/luma-web": "https://unpkg.com/@lumaai/luma-web@0.2.0/dist/library/luma-web.module.js"
        }
    }
    </script>
    <script type="module">
    import { WebGLRenderer, PerspectiveCamera, Scene, Color, Vector2, Vector3, SphereGeometry, CylinderGeometry, BoxGeometry, MeshBasicMaterial, Mesh, TextureLoader, PlaneGeometry, DoubleSide, MeshStandardMaterial, Texture, MathUtils, Matrix4, Raycaster, Plane } from 'three';

    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { LumaSplatsThree } from '@lumaai/luma-web';
    import { sampleCpuPointsForFocus, findClosestSampleToRay, computeScreenDistancePx } from './tap-focus-refinement.mjs';

    function isChrome() {
        return /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
    }

    // Parameters
    const parameters = {
        camera: {
            minHeightAboveTarget: 0.12,
            minY: 0.14,
            maxZoomOut: 1000,
            startPosition: { x: 0.2, y: 0.55, z: 2.8 },
        },
        scene: {
            origin: { x: 0, y: -0.06, z: 0 },
            targetLimit: null  // null = no X/Z bounds on center point; use { x: 2, z: 2 } to restrict
        },
        animation: {
            autoRotate: false,
            startRadius: 2.9,
            speed: -0.0016,
            initialAngle: 294,
            center: { x: 0, y: -0.06, z: 0 },
            path: {
                enabled: true,
                loop: true,
                speed: 1,
                checkpoints: [
                    {
                        position: { x: 4.047838, y: 0.167516, z: -2.455482 },
                        lookAt: { x: 0.91758, y: -0.06, z: -0.1125 },
                        duration: 6
                    },
                    {
                        position: { x: 0.980195, y: 0.424331, z: -1.396408 },
                        lookAt: { x: -0.711801, y: -0.06, z: 0.761672 },
                        duration: 6
                    },
                    {
                        position: { x: -2.565974, y: 0.795137, z: -1.099114 },
                        lookAt: { x: -0.513935, y: -0.06, z: 0.602438 },
                        duration: 6
                    },
                    {
                        position: { x: -3.06098, y: 0.588326, z: 0.953851 },
                        lookAt: { x: -0.499336, y: -0.06, z: 0.59773 },
                        duration: 6
                    },
                    {
                        position: { x: -1.551757, y: 0.678814, z: 2.079809 },
                        lookAt: { x: -0.527514, y: -0.06, z: 0.583859 },
                        duration: 6
                    },
                    {
                        position: { x: 1.182302, y: 0.257698, z: 0.247441 },
                        lookAt: { x: -0.602104, y: -0.06, z: 0.580436 },
                        duration: 6
                    },
                    {
                        position: { x: 3.994974, y: 0.190696, z: -1.685259 },
                        lookAt: { x: -0.848563, y: -0.06, z: -0.116917 },
                        duration: 6
                    },
                    {
                        position: { x: 6.314053, y: 0.784203, z: -2.670156 },
                        lookAt: { x: -0.958903, y: -0.06, z: -0.19409 },
                        duration: 6
                    },
                    {
                        position: { x: -0.37479, y: 0.605938, z: -3.856862 },
                        lookAt: { x: 0.080497, y: -0.06, z: 0.698219 },
                        duration: 6
                    },
                    {
                        position: { x: -4.514964, y: 1.179413, z: -0.337807 },
                        lookAt: { x: -0.044307, y: -0.06, z: 0.507526 },
                        duration: 6
                    },
                    {
                        position: { x: -2.053034, y: 1.316579, z: 3.868697 },
                        lookAt: { x: 0.415465, y: -0.06, z: 0.239249 },
                        duration: 6
                    },
                    {
                        position: { x: 5.452634, y: 0.497917, z: -2.833151 },
                        lookAt: { x: 0.268662, y: -0.06, z: -0.209508 },
                        duration: 6
                    }
                ]
            },
            editor: {
                enabled: true,
                defaultOpen: false
            }
        },
        rebound: {
            speed: 0.2,
            elasticity: 0.05,
            minY: { speed: 0.06, overshoot: 0.06, maxOvershoot: 0.015, settleThreshold: 0.02 }
        },
        minYSpring: {
            stiffness: 2.5,
            damping: 0.88,
            bounceCoefficient: 0.06,
            maxBounceVelocity: 0.03,
            adaptive: true  // scale force by sqrt(penetration) and distance for gentle feel
        },
        minDistance: {
            center: { x: 0, y: -0.06, z: 0 },
            radius: 0.8
        },
        maxDistance: {
            base: 8.2,
            responsiveness: 1.4
        },
        developerMode: false,  // Set this to true to activate developer mode
        developerToolsVisible: true,  // Editor buttons (splat, lot, animation) in top right
        splatEditor: {
            enabled: true,
            defaultOpen: false
        },
        // Compass configuration - easily adjustable
        compass: {
            northDirection: 358,  // 0 = positive Z axis, 90 = positive X axis, etc.
            // northButtonMode: 'north' = rotate camera to face north; 'animationStart' = jump to path checkpoint 0
            northButtonMode: 'animationStart'  // 'north' = rotate to face north; 'animationStart' = jump to path checkpoint 0
        }
    };

    // "Sold" hotspot configuration (optional overlay text)
    const soldHotspotConfigurations = [
        //{ text: 'SOLD', position: { x: 0.22, y: 0.5, z: -0.85 }, scale: 0.2, verticalOffset: 0.06 },
    ];

    // TapDots: info icons (No Photos) = label pops up above; camera icons = photo popup with caption
    // Camera icons use photos[] array for carousel; add more paths to include more images per location
    // Per-hole: each hole has its own tap dots (no cross-referencing between holes)
    const tapDotsConfig = { visible: true };  // Tap dot title overlay enabled
    const tapDotConfigurationsByHole = [
        // Hole 15
        [
            { position: { x: -0.524709, y: 0.119, z: 0.364283 }, scale: 0.225, icon: 'info', caption: 'Hole 15', priority: 'low' },
        ],
        // Hole 18
        [
            { position: { x: -0.18843, y: -0.049, z: -0.142504 }, scale: 0.225, icon: 'info', caption: 'Hole 18', priority: 'low' },
            { position: { x: 1.225352, y: -0.092, z: 0.190538 }, scale: 0.225, icon: 'info', caption: 'Driving Range', priority: 'low' },
        ],
        // Clubhouse
        [
            { position: { x: 0.022137, y: -0.044, z: -0.017594 }, scale: 0.225, icon: 'info', caption: 'Clubhouse', priority: 'low' },
        ],
        // Hole 3 & 4
        [
            { position: { x: -3.122833, y: -0.464, z: 0.947059 }, scale: 0.225, icon: 'info', caption: 'Hole 3', priority: 'low' },
            { position: { x: 0.605007, y: -0.398, z: 0.233991 }, scale: 0.225, icon: 'info', caption: 'Hole 4', priority: 'low' },
        ],
    ];

    // Tap detection: scale with visual size (so hit area matches apparent dot size)
    const tapRadiusMultiplier = 1.6; // Hit area = visible dot radius * this (slightly larger for easier tap)

    // Centralized control section for BorderDots and BorderLines (lot lines)
    // Per-hole: each hole has its own lot lines (no cross-referencing between holes)
    const borderDotPositionsByHole = [
        // Hole 15
        [
            { name: 'Lot_V1', position: { x: 0.619899, y: -0.07236, z: 0.910146 } },
            { name: 'Lot_V4', position: { x: 0.613988, y: -0.12955, z: -0.646242 } },
            { name: 'Lot_V5', position: { x: 0.432838, y: -0.1341, z: -0.769965 } },
            { name: 'Lot_V6', position: { x: 0.356929, y: -0.13712, z: -0.852191 } },
            { name: 'Lot_V7', position: { x: 0.134329, y: -0.139, z: -0.90331 } },
            { name: 'Lot_V8', position: { x: 0.047765, y: -0.14156, z: -0.972969 } },
            { name: 'Lot_V9', position: { x: -0.858899, y: -0.15415, z: -1.315852 } },
            { name: 'Lot_V10', position: { x: -0.903571, y: -0.15539, z: -1.3497 } },
            { name: 'Lot_V11', position: { x: -1.743049, y: -0.152, z: -1.527306 } },
            { name: 'Lot_V12', position: { x: -1.877436, y: -0.105, z: -0.181094 } },
            { name: 'Lot_V13', position: { x: -1.830478, y: -0.06, z: 0.921714 } },
            { name: 'Lot_V15', position: { x: -0.851375, y: -0.12134, z: -0.344962 } },
            { name: 'Lot_V16', position: { x: -0.860571, y: -0.07236, z: 0.910337 } },
            { name: 'Lot_V18', position: { x: 0.608931, y: -0.09746, z: 0.230155 } },
            { name: 'Lot_V19', position: { x: -0.907887, y: -0.15727, z: -1.432879 } },
            { name: 'Lot_V20', position: { x: -0.970607, y: -0.1613, z: -1.52137 } },
            { name: 'Lot_V21', position: { x: 0.480793, y: -0.09984, z: 0.164791 } },
            { name: 'Lot_V22', position: { x: -0.208798, y: -0.14321, z: -1.079954 } },
            { name: 'Lot_V23', position: { x: -0.68705, y: -0.15194, z: -1.24425 } },
            { name: 'Lot_V24', position: { x: -0.520112, y: -0.14624, z: -1.139954 } },
            { name: 'Lot_V25', position: { x: -0.140558, y: -0.14154, z: -1.024829 } }
        ],
        // Hole 18, Clubhouse, Hole 3 & 4 - empty for now
        [], [], []
    ];

    const borderLineConnectionsByHole = [
        // Hole 15
        [
            { start: 'Lot_V1', end: 'Lot_V18' },
            { start: 'Lot_V18', end: 'Lot_V4' },
            { start: 'Lot_V4', end: 'Lot_V5' },
            { start: 'Lot_V5', end: 'Lot_V6' },
            { start: 'Lot_V6', end: 'Lot_V7' },
            { start: 'Lot_V7', end: 'Lot_V8' },
            { start: 'Lot_V8', end: 'Lot_V25' },
            { start: 'Lot_V25', end: 'Lot_V22' },
            { start: 'Lot_V22', end: 'Lot_V24' },
            { start: 'Lot_V24', end: 'Lot_V23' },
            { start: 'Lot_V23', end: 'Lot_V9' },
            { start: 'Lot_V9', end: 'Lot_V10' },
            { start: 'Lot_V10', end: 'Lot_V19' },
            { start: 'Lot_V19', end: 'Lot_V20' },
            { start: 'Lot_V20', end: 'Lot_V11' },
            { start: 'Lot_V11', end: 'Lot_V12' },
            { start: 'Lot_V12', end: 'Lot_V13' },
            { start: 'Lot_V13', end: 'Lot_V16' },
            { start: 'Lot_V16', end: 'Lot_V1' },
            { start: 'Lot_V16', end: 'Lot_V15' },
            { start: 'Lot_V15', end: 'Lot_V9' },
            { start: 'Lot_V18', end: 'Lot_V21' },
            { start: 'Lot_V21', end: 'Lot_V15' }
        ],
        // Hole 18, Clubhouse, Hole 3 & 4 - empty
        [], [], []
    ];

    // Lot lines visibility: independent (always shown) or tied to specific holes/splats
    // - visible: false = hide lot lines entirely (re-enable when needed)
    // - holes: undefined | null = independent, always visible regardless of selected splat
    // - holes: [0, 1, 2] = only visible when hole index is 0, 1, or 2
    const lotLinesConfig = {
        visible: false,  // off for now; set true when needed
        holes: undefined  // independent (always shown). Use e.g. holes: [0, 1] to tie to holes 0 and 1 only
    };

    // Border Dot Parameters
    const borderDotParams = {
        radius: 0.01,
        widthSegments: 16,
        heightSegments: 16,
        color: 0xd3d3d3
    };

    const lotEditState = {
        active: false,
        selectedVertexName: null,
        pointerNDC: new Vector2(),
        dragRaycaster: new Raycaster(),
        dragPlane: new Plane(new Vector3(0, 1, 0), -0.1),
        dragging: {
            active: false,
            pointerId: null,
            vertexName: null,
            planeY: 0.1,
            mergeTargetName: null,
            mergeHoverStartMs: 0,
            mergeTimerId: null
        },
        midpointButtons: new Map(),
        suppressNextClick: false,
        cameraSnapshot: null,
        mergeScreenDistancePx: 20,
        mergeHoldMs: 1500,
        midpointMinScreenDistancePx: 130,
        midpointMinSpacingPx: 44,
        midpointMaxButtons: 10,
        draggingTapDot: null,
        draggingTapDotPointerId: null,
        draggingTapDotPlaneY: 0,
        lastTapDotPointerDownTime: 0,
        lastTapDotPointerDownTarget: null,
        selectedTapDot: null,
        potentialTapDotDrag: null,
        potentialTapDotDragPointerId: null
    };

    // Base sizes for TapDots and Icons
    const tapDotBaseSize = 0.08; // TapDot sphere size (doubled for better visibility)
    const iconBaseSize = 0.16;   // Icon size (doubled for better visibility)

    const chromeAnimationScale = isChrome() ? 0.5 : 1;
    const rendererPixelRatioCap = 1.8;

    let renderer = new WebGLRenderer({ antialias: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(new Color(0x000000));
    renderer.setPixelRatio(Math.min(window.devicePixelRatio * 0.8, rendererPixelRatioCap));
    document.body.appendChild(renderer.domElement);
    const tapdotLabelsLayerEl = document.getElementById('tapdot-labels-layer');
    if (tapdotLabelsLayerEl) document.body.appendChild(tapdotLabelsLayerEl);

    let scene = new Scene();

    let camera = new PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, parameters.camera.maxZoomOut);
    camera.position.set(parameters.camera.startPosition.x, parameters.camera.startPosition.y, parameters.camera.startPosition.z);

    let controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.zoomSpeed = 0.5;  // Original orbital: halved zoom sensitivity
    controls.minDistance = 0.6;
    controls.maxDistance = calculateMaxDistance();
    controls.minPolarAngle = 0;
    controls.maxPolarAngle = MathUtils.degToRad(85);
    if ('zoomToCursor' in controls) {
        controls.zoomToCursor = true;
    }
    controls.target.set(parameters.scene.origin.x, parameters.scene.origin.y, parameters.scene.origin.z);
    controls.update();

    controls.addEventListener('change', () => {
        if (typeof tapFocusTransition !== 'undefined' && tapFocusTransition.active) return;
        // Min Y rebound: original simple lerp (from initial commit)
        const activeConfig = getActiveHoleConfig();
        const targetY = activeConfig?.view?.target?.y ?? parameters.scene.origin.y;
        const minYFromTarget = targetY + parameters.camera.minHeightAboveTarget;
        const minY = Math.max(parameters.camera.minY, minYFromTarget);
        if (camera.position.y < minY) {
            const dist = camera.position.distanceTo(controls.target);
            const distanceScale = Math.min(3, Math.max(0.6, dist / 1.2));
            const effectiveSpeed = parameters.rebound.speed * distanceScale;
            camera.position.y += (minY - camera.position.y) * effectiveSpeed;
        }

        // Restrict target movement on X and Z axes (when targetLimit is set)
        const tl = parameters.scene.targetLimit;
        if (tl && typeof tl.x === 'number' && typeof tl.z === 'number') {
            const clampRebound = (current, min, max) => {
                let clamped = Math.min(Math.max(current, min), max);
                return clamped + (current - clamped) * parameters.rebound.elasticity;
            };
            controls.target.x = clampRebound(controls.target.x, -tl.x, tl.x);
            controls.target.z = clampRebound(controls.target.z, -tl.z, tl.z);
        }
        const preserveLookTargetY = (
            (typeof pathAnimationState !== 'undefined' && pathAnimationState.enabled) ||
            (typeof tapFocusTransition !== 'undefined' && tapFocusTransition.active)
        );
        if (!preserveLookTargetY) {
            const fallbackY = parameters.scene.origin.y;
            controls.target.y = Number.isFinite(manualFocusTargetY) ? manualFocusTargetY : fallbackY; // Preserve tap focus Y when set
        }
    });

    // Developer mode toggle
    const developerMode = parameters.developerMode;

    // Golf hole configurations. Each hole can be tuned independently (source, orientation, camera and animation).
    const holeConfigurations = [
        {
            id: 'hole-15',
            label: 'Hole 15',
            source: 'https://lumalabs.ai/embed/4f1a479a-1d13-4178-ade4-75a8fd4d9968?mode=sparkles&background=%23ffffff&color=%23000000&showTitle=true&loadBg=true&logoPosition=bottom-left&infoPosition=bottom-right&cinematicVideo=undefined&showMenu=false',
            revealDuration: 2.8,
            splat: {
                position: { x: 0, y: 0.238, z: 0 },
                rotation: { x: -1.2, y: 0, z: -3.6 },
                scale: 1
            },
            view: {
                startPosition: { x: 0.22, y: 0.6, z: 2.75 },
                target: { x: 0, y: -0.06, z: 0 },
                minDistance: 0.65,
                maxDistance: 10.4,
                minPolarAngle: 14,
                maxPolarAngle: 84,
                northDirection: 358
            },
            animation: {
                autoRotate: false,
                speed: -0.0015,
                startRadius: 2.8,
                initialAngle: 292,
                center: { x: 0, y: -0.06, z: 0 }
            },
            path: null  // Uses parameters.animation.path at init (Hole 15's camera path)
        },
        {
            id: 'hole-18',
            label: 'Hole 18',
            source: 'https://lumalabs.ai/embed/5c2af9e1-b55f-407c-ad17-d5ea73d4a2ee?mode=sparkles&background=%23ffffff&color=%23000000&showTitle=true&loadBg=true&logoPosition=bottom-left&infoPosition=bottom-right&cinematicVideo=undefined&showMenu=false',
            revealDuration: 2.6,
            splat: {
                position: { x: 0, y: 0.32, z: 0 },
                rotation: { x: 0, y: 4, z: 0 },
                scale: 1
            },
            view: {
                startPosition: { x: -0.36, y: 0.58, z: 2.68 },
                target: { x: 0, y: -0.06, z: 0 },
                minDistance: 0.62,
                maxDistance: 10.8,
                minPolarAngle: 14,
                maxPolarAngle: 84,
                northDirection: 10
            },
            animation: {
                autoRotate: false,
                speed: -0.0016,
                startRadius: 2.9,
                initialAngle: 310,
                center: { x: 0, y: -0.06, z: 0 }
            },
            path: {
                enabled: true,
                loop: true,
                speed: 1,
                checkpoints: [
                    { position: { x: -4.028567, y: 0.572872, z: 1.759158 }, lookAt: { x: -0.964374, y: -0.09405, z: 0.981995 }, duration: 5 },
                    { position: { x: 1.166812, y: 0.475135, z: 2.54659 }, lookAt: { x: -1.198476, y: -0.127021, z: 0.528492 }, duration: 5 },
                    { position: { x: 3.899295, y: 0.754653, z: 1.662439 }, lookAt: { x: -1.483479, y: -0.127021, z: 0.723575 }, duration: 5 },
                    { position: { x: 3.605466, y: 0.354121, z: -2.241904 }, lookAt: { x: 0.337206, y: -0.079658, z: -0.11609 }, duration: 5 },
                    { position: { x: -3.586367, y: 0.267657, z: 0.17056 }, lookAt: { x: -1.177208, y: -0.099678, z: 0.360242 }, duration: 5 }
                ]
            }
        },
        {
            id: 'clubhouse',
            label: 'Clubhouse',
            source: 'https://lumalabs.ai/embed/f1e713a9-7bc4-43f0-8cb1-9c8fef376382?mode=sparkles&background=%23ffffff&color=%23000000&showTitle=true&loadBg=true&logoPosition=bottom-left&infoPosition=bottom-right&cinematicVideo=undefined&showMenu=false',
            revealDuration: 2.7,
            splat: {
                position: { x: 0, y: 0.45, z: 0 },
                rotation: { x: 0, y: -6, z: 0 },
                scale: 1
            },
            view: {
                startPosition: { x: 0.46, y: 0.61, z: 2.86 },
                target: { x: 0, y: -0.06, z: 0 },
                minDistance: 0.7,
                maxDistance: 11.2,
                minPolarAngle: 14,
                maxPolarAngle: 84,
                northDirection: 24
            },
            animation: {
                autoRotate: false,
                speed: -0.00145,
                startRadius: 3,
                initialAngle: 274,
                center: { x: 0, y: -0.06, z: 0 }
            },
            path: {
                enabled: true,
                loop: true,
                speed: 1,
                checkpoints: [
                    { position: { x: 3.507141, y: 0.138803, z: 1.667063 }, lookAt: { x: 0.536174, y: -0.108594, z: 0.223898 }, duration: 5 },
                    { position: { x: 1.528803, y: 0.245535, z: -1.357343 }, lookAt: { x: -0.051607, y: -0.120801, z: -0.029416 }, duration: 5 },
                    { position: { x: -1.599397, y: 0.317612, z: -1.389454 }, lookAt: { x: -0.051607, y: -0.120801, z: -0.029416 }, duration: 5 },
                    { position: { x: -1.231036, y: 0.135426, z: 0.150345 }, lookAt: { x: -0.025049, y: -0.120801, z: -0.079923 }, duration: 5 },
                    { position: { x: -1.809225, y: 0.494415, z: 3.490343 }, lookAt: { x: -0.060849, y: -0.120801, z: 0.048164 }, duration: 5 },
                    { position: { x: 3.686517, y: 1.476685, z: 3.019775 }, lookAt: { x: -0.115363, y: -0.120801, z: -0.004466 }, duration: 5 }
                ]
            }
        },
        {
            id: 'hole-3-4',
            label: 'Hole 3 & 4',
            source: 'https://lumalabs.ai/embed/39b7b61b-1c13-4cda-b10d-886b723c9a6a?mode=sparkles&background=%23ffffff&color=%23000000&showTitle=true&loadBg=true&logoPosition=bottom-left&infoPosition=bottom-right&cinematicVideo=undefined&showMenu=false',
            revealDuration: 2.6,
            splat: {
                position: { x: 0, y: 0, z: 0 },
                rotation: { x: 0, y: 8, z: 0 },
                scale: 1
            },
            view: {
                startPosition: { x: -0.24, y: 0.57, z: 2.66 },
                target: { x: 0, y: -0.06, z: 0 },
                minDistance: 0.64,
                maxDistance: 11,
                minPolarAngle: 14,
                maxPolarAngle: 84,
                northDirection: 36
            },
            animation: {
                autoRotate: false,
                speed: -0.00155,
                startRadius: 2.85,
                initialAngle: 332,
                center: { x: 0, y: -0.06, z: 0 }
            },
            path: {
                enabled: true,
                loop: true,
                speed: 1,
                checkpoints: [
                    { position: { x: 2.757621, y: 0.14, z: -1.856277 }, lookAt: { x: 0.838959, y: -0.397609, z: -0.70158 }, duration: 5 },
                    { position: { x: -6.383873, y: 0.527827, z: -1.453392 }, lookAt: { x: -2.852345, y: -0.406154, z: 0.600815 }, duration: 5 },
                    { position: { x: -3.477308, y: 0.139992, z: 2.074735 }, lookAt: { x: -2.161637, y: -0.39062, z: 1.341477 }, duration: 5 },
                    { position: { x: -1.201707, y: 0.137366, z: 1.059447 }, lookAt: { x: 0.509912, y: -0.379055, z: 0.269093 }, duration: 5 },
                    { position: { x: 2.34527, y: 0.137455, z: 1.421066 }, lookAt: { x: 0.564805, y: -0.379055, z: 0.237545 }, duration: 5 },
                    { position: { x: 4.729459, y: 0.730712, z: -1.764914 }, lookAt: { x: 1.392704, y: -0.362453, z: 0.008773 }, duration: 5 }
                ]
            }
        }
    ];

    const holeSplats = new Array(holeConfigurations.length).fill(null);
    let activeHoleIndex = 0;
    let manualFocusTargetY = null;
    let angle = MathUtils.degToRad(parameters.animation.initialAngle);
    let autoRotate = parameters.animation.autoRotate;

    function getActiveHoleConfig() {
        return holeConfigurations[activeHoleIndex] || holeConfigurations[0];
    }

    function applyHoleSplatTransform(holeSplat, holeConfig) {
        const splatConfig = holeConfig && holeConfig.splat ? holeConfig.splat : {};
        const position = splatConfig.position || { x: 0, y: 0, z: 0 };
        const rotation = splatConfig.rotation || { x: 0, y: 0, z: 0 };
        const scale = Number.isFinite(splatConfig.scale) ? splatConfig.scale : 1;
        holeSplat.position.set(position.x, position.y, position.z);
        holeSplat.rotation.x = MathUtils.degToRad(rotation.x || 0);
        holeSplat.rotation.y = MathUtils.degToRad(rotation.y || 0);
        holeSplat.rotation.z = MathUtils.degToRad(rotation.z || 0);
        holeSplat.scale.setScalar(scale);
    }

    function createHoleSplat(holeConfig) {
        const holeSplat = new LumaSplatsThree({
            source: holeConfig.source,
            particleRevealEnabled: true,
            particleRevealDuration: holeConfig.revealDuration || 2.7
        });
        if (holeSplat.material) {
            holeSplat.material.depthTest = true;
        }
        holeSplat.renderOrder = 999;
        applyHoleSplatTransform(holeSplat, holeConfig);
        holeSplat.visible = false;
        scene.add(holeSplat);
        return holeSplat;
    }

    function ensureHoleSplat(index) {
        if (!holeSplats[index]) {
            holeSplats[index] = createHoleSplat(holeConfigurations[index]);
        }
        return holeSplats[index];
    }

    function getConfiguredMaxDistance(holeConfig) {
        const configuredMaxDistance = holeConfig && holeConfig.view ? holeConfig.view.maxDistance : undefined;
        if (Number.isFinite(configuredMaxDistance)) return configuredMaxDistance;
        return calculateMaxDistance();
    }

    function applyHoleAnimation(holeConfig) {
        const animationConfig = holeConfig && holeConfig.animation ? holeConfig.animation : {};
        const center = animationConfig.center || (holeConfig && holeConfig.view ? holeConfig.view.target : parameters.scene.origin);
        parameters.animation.center = {
            x: center.x,
            y: center.y,
            z: center.z
        };
        parameters.animation.startRadius = Number.isFinite(animationConfig.startRadius)
            ? animationConfig.startRadius
            : camera.position.distanceTo(controls.target);
        parameters.animation.speed = (Number.isFinite(animationConfig.speed) ? animationConfig.speed : -0.0014) * chromeAnimationScale;
        parameters.animation.initialAngle = Number.isFinite(animationConfig.initialAngle) ? animationConfig.initialAngle : 0;
        parameters.animation.autoRotate = !!animationConfig.autoRotate;
        angle = MathUtils.degToRad(parameters.animation.initialAngle);
        autoRotate = parameters.animation.autoRotate;
    }

    function applyHoleView(holeConfig, resetCamera = true) {
        const viewConfig = holeConfig && holeConfig.view ? holeConfig.view : {};
        const target = viewConfig.target || parameters.scene.origin;
        manualFocusTargetY = null;
        if (typeof tapFocusTransition !== 'undefined') {
            tapFocusTransition.active = false;
            tapFocusState.debug.transitionActive = false;
            tapFocusState.debug.transitionProgress = 0;
            tapFocusFeedback.active = false;
            tapFocusState.debug.feedbackActive = false;
            tapFocusState.debug.feedbackProgress = 0;
            tapFocusState.debug.feedbackScreenX = null;
            tapFocusState.debug.feedbackScreenY = null;
            if (tapFocusFeedbackEl) {
                tapFocusFeedbackEl.style.opacity = '0';
                tapFocusFeedbackEl.style.display = 'none';
            }
        }
        controls.target.set(target.x, target.y, target.z);
        controls.minDistance = Number.isFinite(viewConfig.minDistance) ? viewConfig.minDistance : 0.6;
        controls.maxDistance = Math.max(controls.minDistance + 0.01, getConfiguredMaxDistance(holeConfig));
        controls.minPolarAngle = MathUtils.degToRad(Number.isFinite(viewConfig.minPolarAngle) ? viewConfig.minPolarAngle : 14);
        controls.maxPolarAngle = MathUtils.degToRad(Number.isFinite(viewConfig.maxPolarAngle) ? viewConfig.maxPolarAngle : 84);

        if (resetCamera && viewConfig.startPosition) {
            camera.position.set(
                viewConfig.startPosition.x,
                viewConfig.startPosition.y,
                viewConfig.startPosition.z
            );
        }

        if (Number.isFinite(viewConfig.northDirection)) {
            parameters.compass.northDirection = viewConfig.northDirection;
        }
        controls.update();
        updateCompassIcon();
    }

    function updateHoleCarouselLabel() {
        const holeLabelText = document.getElementById('holeLabelText');
        const holeLabelButton = document.getElementById('holeLabelButton');
        if (!holeLabelText) return;
        const config = getActiveHoleConfig();
        const label = config ? config.label : 'Hole 15';
        holeLabelText.textContent = label;
        if (holeLabelButton) {
            holeLabelButton.setAttribute('aria-label', label);
        }
    }

    function updateHoleCarouselButtons() {
        const prevBtn = document.getElementById('holePrevButton');
        const nextBtn = document.getElementById('holeNextButton');
        const total = holeConfigurations.length;
        const hasMultiple = total > 1;
        if (prevBtn) prevBtn.disabled = !hasMultiple;
        if (nextBtn) nextBtn.disabled = !hasMultiple;
    }

    function setActiveHole(nextIndex, options = {}) {
        if (!holeConfigurations.length) return;
        const totalHoles = holeConfigurations.length;
        const normalizedIndex = ((nextIndex % totalHoles) + totalHoles) % totalHoles;
        const resetCamera = options.resetCamera !== false;
        const nextConfig = holeConfigurations[normalizedIndex];
        const nextSplat = ensureHoleSplat(normalizedIndex);

        activeHoleIndex = normalizedIndex;
        holeSplats.forEach((holeSplat, index) => {
            if (!holeSplat) return;
            holeSplat.visible = index === activeHoleIndex;
        });
        borderDots = borderDotsByHole[activeHoleIndex] || {};
        borderLines = borderLinesByHole[activeHoleIndex] || [];
        borderLineConnections = borderLineConnectionsByHole[activeHoleIndex] || [];
        pathAnimationState = pathAnimationStateByHole[activeHoleIndex] || pathAnimationStateByHole[0];
        pathAnimationState.playing = false;
        pathAnimationState.segmentIndex = 0;
        pathAnimationState.segmentElapsed = 0;
        if (pathAnimationState.enabled && pathAnimationState.checkpoints.length > 1) {
            pathAnimationState.playing = true;
            autoRotate = false;
        }
        applyHoleSplatTransform(nextSplat, nextConfig);
        applyHoleView(nextConfig, resetCamera);
        applyHoleAnimation(nextConfig);
        updateHoleCarouselLabel();
        updateHoleCarouselButtons();
        if (typeof refreshBorderVisualState === 'function') refreshBorderVisualState();
        if (typeof syncAnimationEditorFromState === 'function') syncAnimationEditorFromState();
        if (typeof syncSplatEditorFromConfig === 'function') syncSplatEditorFromConfig();
    }

    function cycleHole(direction) {
        if (!holeConfigurations.length) return;
        const nextIndex = activeHoleIndex + direction;
        setActiveHole(nextIndex);
    }

    controls.addEventListener('change', () => {
        if (typeof tapFocusTransition !== 'undefined' && tapFocusTransition.active) return;
        const preserveLookTargetY = (
            (typeof pathAnimationState !== 'undefined' && pathAnimationState.enabled) ||
            (typeof manualFocusTargetY === 'number' && Number.isFinite(manualFocusTargetY))
        );
        if (!preserveLookTargetY) {
            const activeConfig = getActiveHoleConfig();
            const targetY = activeConfig && activeConfig.view && activeConfig.view.target
                ? activeConfig.view.target.y
                : parameters.scene.origin.y;
            controls.target.y = targetY;
        }
        // Min Y boundary handled in animate loop with spring bounce
    });

    if (developerMode) {
        const developerControls = document.getElementById('developerControls');
        const previousHoleButton = document.getElementById('toggleSplat1');
        const nextHoleButton = document.getElementById('toggleSplat2');
        if (developerControls) developerControls.style.display = 'block';
        if (previousHoleButton) {
            previousHoleButton.textContent = 'Previous Hole';
            previousHoleButton.addEventListener('click', () => cycleHole(-1));
        }
        if (nextHoleButton) {
            nextHoleButton.textContent = 'Next Hole';
            nextHoleButton.addEventListener('click', () => cycleHole(1));
        }
    }

    // TapDots Logic
    let tapDots = [];
    const textureLoader = new TextureLoader();
    const iconTextures = {};
    const iconsToLoad = [
        { name: 'info', url: 'https://raw.githubusercontent.com/HansenHomeAI/WhiteInfoIcon/main/3TestIcons-8.png' },
        { name: 'camera', url: 'https://raw.githubusercontent.com/HansenHomeAI/WhiteCameraIcon/main/3TestIcons-9.png' },
    ];

    let iconsLoaded = 0;
    function onIconsReady() {
        const configs = tapDotConfigurationsByHole || [];
        let globalIndex = 0;
        for (let holeIdx = 0; holeIdx < configs.length; holeIdx++) {
            const holeConfigs = configs[holeIdx] || [];
            holeConfigs.forEach((config) => {
                createTapDot(config, globalIndex++, holeIdx);
            });
        }
    }

    function getActiveTapDots() {
        return tapDots.filter((td) => td.holeIndex === activeHoleIndex);
    }
    iconsToLoad.forEach(iconData => {
        textureLoader.load(iconData.url, (texture) => {
            iconTextures[iconData.name] = texture;
            iconsLoaded++;
            if (iconsLoaded === iconsToLoad.length) {
                onIconsReady();
            }
        },
        undefined,
        (err) => {
            console.error(`Error loading texture: ${iconData.url}`, err);
        });
    });

    // Start render loop on next frame so 3D scene displays without waiting for icon textures.
    // Icons are only needed for tap dots; the Luma splat and scene render right away.
    requestAnimationFrame(animate);

    function generateUniqueColor(index) {
        index += 1;
        const r = (index * 37) % 256;
        const g = (index * 57) % 256;
        const b = (index * 79) % 256;
        const minComponent = 50;
        const maxComponent = 255;
        const range = maxComponent - minComponent;
        const adjustComponent = (value) => Math.floor((value / 255) * range + minComponent);
        const finalR = adjustComponent(r);
        const finalG = adjustComponent(g);
        const finalB = adjustComponent(b);
        return `#${finalR.toString(16).padStart(2,'0')}${finalG.toString(16).padStart(2,'0')}${finalB.toString(16).padStart(2,'0')}`;
    }

    function createTapDot(config, index, holeIndex) {
        const { position, scale, icon } = config;
        const dotColor = generateUniqueColor(index);
        let dotGeometry = new SphereGeometry(tapDotBaseSize, 32, 32);
        let dotMaterial = new MeshBasicMaterial({
            color: 0x2C2C2E,
            transparent: true,
            opacity: 0.7
        });
        let dot = new Mesh(dotGeometry, dotMaterial);
        dot.position.set(position.x, position.y, position.z);
        dot.scale.setScalar(scale || 1);
        dot.visible = false;

        const iconGeometry = new PlaneGeometry(iconBaseSize, iconBaseSize);
        const iconMaterial = new MeshBasicMaterial({
            map: iconTextures[icon],
            transparent: true,
            alphaTest: 0.5
        });
        let iconMesh = new Mesh(iconGeometry, iconMaterial);
        iconMesh.position.copy(dot.position);
        iconMesh.scale.setScalar(scale || 1);
        iconMesh.visible = false;

        let labelEl = null;
        const tapDotEntry = { dot, iconMesh, color: dotColor, scale, index, holeIndex: holeIndex ?? 0, config, labelEl: null };
        if (config.caption) {
            labelEl = document.createElement('div');
            labelEl.className = 'tapdot-label-bubble';
            const gradId = 'labelOutline-' + index;
            const pathD = 'M 21 0 L 119 0 Q 140 0 140 21 Q 140 42 119 42 L 74 42 L 70 47 L 66 42 L 21 42 Q 0 42 0 21 Q 0 0 21 0 Z';
            labelEl.innerHTML = '<svg class="tapdot-label-bg" viewBox="0 0 140 47" preserveAspectRatio="none"><defs><linearGradient id="' + gradId + '" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="rgba(255,255,255,0.4)"/><stop offset="41%" stop-color="rgba(255,255,255,0)"/><stop offset="57%" stop-color="rgba(255,255,255,0)"/><stop offset="100%" stop-color="rgba(255,255,255,0.4)"/></linearGradient></defs><path d="' + pathD + '" fill="none" stroke="url(#' + gradId + ')" stroke-width="1.4"/></svg><span class="tapdot-label-text">' + config.caption + '</span>';
            tapDotEntry.labelEl = labelEl;
            const labelsLayer = document.getElementById('tapdot-labels-layer');
            if (labelsLayer) labelsLayer.appendChild(labelEl);
            labelEl.addEventListener('pointerdown', (e) => {
                if (!lotEditState.active || e.button !== 0) return;
                e.preventDefault();
                e.stopPropagation();
                lotEditState.potentialTapDotDrag = tapDotEntry;
                lotEditState.potentialTapDotDragPointerId = e.pointerId;
                lotEditState.suppressNextClick = true;
                setLotEditorStatus('Drag to move label.');
            }, { passive: false });
        }

        tapDots.push(tapDotEntry);
        scene.add(dot);
        scene.add(iconMesh);
    }

    const hiddenCanvas = document.createElement('canvas');
    const hiddenContext = hiddenCanvas.getContext('2d');
    hiddenCanvas.width = window.innerWidth;
    hiddenCanvas.height = window.innerHeight;
    hiddenCanvas.style.display = 'none';
    document.body.appendChild(hiddenCanvas);

    const tapFocusSettings = Object.freeze({
        targetSampleCount: 18000,
        maxRayDistanceSq: 0.0055,
        maxScreenDistancePx: 120,
        transitionDurationMs: 360
    });

    const tapFocusState = {
        pointCache: new WeakMap(),
        raycaster: new Raycaster(),
        pointerNDC: new Vector2(),
        inverseWorldMatrix: new Matrix4(),
        localRayOrigin: new Vector3(),
        localRayDirection: new Vector3(),
        worldCandidate: new Vector3(),
        projectedCandidate: new Vector3(),
        debug: {
            attemptCount: 0,
            successCount: 0,
            rejectCount: 0,
            lastRejectedReason: '',
            lastRayDistanceSq: null,
            lastScreenDistancePx: null,
            lastFocusedPoint: null,
            activeSourcePointCount: 0,
            activePointCount: 0,
            activeStride: 0,
            transitionActive: false,
            transitionProgress: 0,
            feedbackActive: false,
            feedbackProgress: 0,
            feedbackScreenX: null,
            feedbackScreenY: null
        }
    };

    const tapFocusTransition = {
        active: false,
        startedAt: 0,
        durationMs: tapFocusSettings.transitionDurationMs,
        startTarget: new Vector3(),
        endTarget: new Vector3()
    };

    const tapFocusFeedback = {
        active: false,
        startedAt: 0,
        durationMs: 560,
        worldPoint: new Vector3(),
        projected: new Vector3()
    };

    const tapFocusFeedbackEl = document.getElementById('tap-focus-feedback');
    if (tapFocusFeedbackEl) tapFocusFeedbackEl.style.display = 'none';

    window.__tapFocusDebug = {
        getState: () => {
            const activeSplat = holeSplats[activeHoleIndex];
            const loader = activeSplat && activeSplat.lumaSplatsWebGL ? activeSplat.lumaSplatsWebGL.loader : null;
            const activeLoaderPointCount = loader && Number.isFinite(loader.cpuPtsCount)
                ? loader.cpuPtsCount
                : loader && Number.isFinite(loader.numSplats)
                    ? loader.numSplats
                    : 0;
            return {
                activeHoleIndex,
                activeLoaderPointCount,
                ...tapFocusState.debug
            };
        }
    };

    function getActiveHoleSplatForTapFocus() {
        const activeSplat = holeSplats[activeHoleIndex];
        if (!activeSplat || !activeSplat.visible) return null;
        return activeSplat;
    }

    function setTapFocusRejectionReason(reason) {
        tapFocusState.debug.lastRejectedReason = reason || '';
    }

    function startTapFocusFeedback(worldPoint) {
        if (!tapFocusFeedbackEl || !worldPoint) return;
        tapFocusFeedback.active = true;
        tapFocusFeedback.startedAt = performance.now();
        tapFocusFeedback.worldPoint.copy(worldPoint);
        tapFocusState.debug.feedbackActive = true;
        tapFocusState.debug.feedbackProgress = 0;
        tapFocusFeedbackEl.style.display = 'block';
    }

    function updateTapFocusFeedback(now = performance.now()) {
        if (!tapFocusFeedbackEl) return false;
        if (!tapFocusFeedback.active) {
            if (tapFocusFeedbackEl.style.display !== 'none') {
                tapFocusFeedbackEl.style.display = 'none';
            }
            return false;
        }
        const elapsedMs = Math.max(0, now - tapFocusFeedback.startedAt);
        const progress = Math.min(elapsedMs / tapFocusFeedback.durationMs, 1);
        const ease = 1 - Math.pow(1 - progress, 3);
        tapFocusFeedback.projected.copy(tapFocusFeedback.worldPoint).project(camera);
        const visible = tapFocusFeedback.projected.z > -1 && tapFocusFeedback.projected.z < 1;
        const screenX = (tapFocusFeedback.projected.x + 1) * 0.5 * window.innerWidth;
        const screenY = (1 - tapFocusFeedback.projected.y) * 0.5 * window.innerHeight;
        tapFocusState.debug.feedbackScreenX = visible ? screenX : null;
        tapFocusState.debug.feedbackScreenY = visible ? screenY : null;
        tapFocusState.debug.feedbackProgress = progress;
        if (visible) {
            const fade = progress < 0.7 ? 1 : (1 - progress) / 0.3;
            const clampedFade = Math.max(0, Math.min(fade, 1));
            tapFocusFeedbackEl.style.left = `${screenX}px`;
            tapFocusFeedbackEl.style.top = `${screenY}px`;
            tapFocusFeedbackEl.style.opacity = `${clampedFade}`;
            tapFocusFeedbackEl.style.transform = `translate(-50%, -50%) scale(${0.88 + ease * 0.12})`;
            tapFocusFeedbackEl.style.display = 'block';
        } else {
            tapFocusFeedbackEl.style.opacity = '0';
            tapFocusFeedbackEl.style.display = 'none';
        }
        if (progress >= 1) {
            tapFocusFeedback.active = false;
            tapFocusState.debug.feedbackActive = false;
            tapFocusState.debug.feedbackProgress = 1;
            tapFocusFeedbackEl.style.opacity = '0';
            tapFocusFeedbackEl.style.display = 'none';
        }
        return true;
    }

    function beginTapFocusTransition(targetPoint) {
        if (!targetPoint) return;
        tapFocusTransition.active = true;
        tapFocusTransition.startedAt = performance.now();
        tapFocusTransition.durationMs = tapFocusSettings.transitionDurationMs;
        tapFocusTransition.startTarget.copy(controls.target);
        tapFocusTransition.endTarget.copy(targetPoint);
        tapFocusState.debug.transitionActive = true;
        tapFocusState.debug.transitionProgress = 0;
    }

    function updateTapFocusTransition(now = performance.now()) {
        if (!tapFocusTransition.active) return false;
        const elapsedMs = Math.max(0, now - tapFocusTransition.startedAt);
        const progress = Math.min(elapsedMs / tapFocusTransition.durationMs, 1);
        const easedProgress = 1 - Math.pow(1 - progress, 3);
        controls.target.lerpVectors(
            tapFocusTransition.startTarget,
            tapFocusTransition.endTarget,
            easedProgress
        );
        manualFocusTargetY = controls.target.y;
        tapFocusState.debug.transitionProgress = progress;
        if (progress >= 1) {
            controls.target.copy(tapFocusTransition.endTarget);
            manualFocusTargetY = tapFocusTransition.endTarget.y;
            tapFocusTransition.active = false;
            tapFocusState.debug.transitionActive = false;
            tapFocusState.debug.transitionProgress = 1;
        }
        return true;
    }

    function getTapFocusSampleCache(holeSplat) {
        if (!holeSplat || !holeSplat.lumaSplatsWebGL || !holeSplat.lumaSplatsWebGL.loader) {
            setTapFocusRejectionReason('splat-loader-not-ready');
            return null;
        }
        const loader = holeSplat.lumaSplatsWebGL.loader;
        const cpuPoints = loader.cpuPoints;
        if (!cpuPoints || !cpuPoints.length) {
            setTapFocusRejectionReason('splat-points-unavailable');
            return null;
        }
        const availablePointCount = Math.floor(cpuPoints.length / 3);
        const loadedPointCount = Number.isFinite(loader.cpuPtsCount)
            ? Math.floor(loader.cpuPtsCount)
            : Number.isFinite(loader.numSplats)
                ? Math.floor(loader.numSplats)
                : availablePointCount;
        const sourcePointCount = Math.max(0, Math.min(availablePointCount, loadedPointCount));
        if (!sourcePointCount) {
            setTapFocusRejectionReason('splat-points-empty');
            return null;
        }

        const cached = tapFocusState.pointCache.get(holeSplat);
        if (cached && cached.sourcePointCount === sourcePointCount) {
            tapFocusState.debug.activeSourcePointCount = cached.sourcePointCount;
            tapFocusState.debug.activePointCount = cached.sampledPointCount;
            tapFocusState.debug.activeStride = cached.stride;
            return cached;
        }

        const sampled = sampleCpuPointsForFocus({
            cpuPoints,
            pointCount: sourcePointCount,
            targetSampleCount: tapFocusSettings.targetSampleCount
        });
        if (!sampled) {
            setTapFocusRejectionReason('splat-sampling-failed');
            return null;
        }
        const cacheEntry = {
            sourcePointCount,
            sampledPointCount: sampled.sampledPointCount,
            stride: sampled.stride,
            samples: sampled.samples
        };
        tapFocusState.pointCache.set(holeSplat, cacheEntry);
        tapFocusState.debug.activeSourcePointCount = cacheEntry.sourcePointCount;
        tapFocusState.debug.activePointCount = cacheEntry.sampledPointCount;
        tapFocusState.debug.activeStride = cacheEntry.stride;
        return cacheEntry;
    }

    function setTapFocusRayFromEvent(event) {
        const bounds = renderer.domElement.getBoundingClientRect();
        tapFocusState.pointerNDC.x = ((event.clientX - bounds.left) / bounds.width) * 2 - 1;
        tapFocusState.pointerNDC.y = -((event.clientY - bounds.top) / bounds.height) * 2 + 1;
        tapFocusState.raycaster.setFromCamera(tapFocusState.pointerNDC, camera);
    }

    function pickWorldPointFromTap(event) {
        if (!event || !Number.isFinite(event.clientX) || !Number.isFinite(event.clientY)) {
            setTapFocusRejectionReason('invalid-tap-event');
            return null;
        }
        const activeSplat = getActiveHoleSplatForTapFocus();
        if (!activeSplat) {
            setTapFocusRejectionReason('active-splat-missing');
            return null;
        }
        const cacheEntry = getTapFocusSampleCache(activeSplat);
        if (!cacheEntry || !cacheEntry.samples || cacheEntry.samples.length < 3) return null;

        setTapFocusRayFromEvent(event);
        activeSplat.updateMatrixWorld(true);
        tapFocusState.inverseWorldMatrix.copy(activeSplat.matrixWorld).invert();
        tapFocusState.localRayOrigin.copy(tapFocusState.raycaster.ray.origin).applyMatrix4(tapFocusState.inverseWorldMatrix);
        tapFocusState.localRayDirection.copy(tapFocusState.raycaster.ray.direction).transformDirection(tapFocusState.inverseWorldMatrix);

        const pick = findClosestSampleToRay({
            samples: cacheEntry.samples,
            rayOrigin: tapFocusState.localRayOrigin,
            rayDirection: tapFocusState.localRayDirection,
            maxDistanceSq: tapFocusSettings.maxRayDistanceSq
        });
        if (!pick) {
            setTapFocusRejectionReason('ray-hit-not-found');
            tapFocusState.debug.lastRayDistanceSq = null;
            tapFocusState.debug.lastScreenDistancePx = null;
            return null;
        }
        tapFocusState.debug.lastRayDistanceSq = pick.distanceSq;
        tapFocusState.worldCandidate.set(pick.x, pick.y, pick.z).applyMatrix4(activeSplat.matrixWorld);

        tapFocusState.projectedCandidate.copy(tapFocusState.worldCandidate).project(camera);
        const screenDistancePx = computeScreenDistancePx({
            ndcX: tapFocusState.projectedCandidate.x,
            ndcY: tapFocusState.projectedCandidate.y,
            viewportWidth: window.innerWidth,
            viewportHeight: window.innerHeight,
            pointerX: event.clientX,
            pointerY: event.clientY
        });
        tapFocusState.debug.lastScreenDistancePx = screenDistancePx;
        if (screenDistancePx > tapFocusSettings.maxScreenDistancePx) {
            setTapFocusRejectionReason('screen-distance-too-large');
            return null;
        }

        return tapFocusState.worldCandidate.clone();
    }

    function focusCameraOnTappedPoint(event) {
        tapFocusState.debug.attemptCount += 1;
        const pickedPoint = pickWorldPointFromTap(event);
        if (!pickedPoint) {
            tapFocusState.debug.rejectCount += 1;
            return false;
        }
        pauseCameraAutomationFromInteraction();
        isAnimatingToNorth = false;
        startTapFocusFeedback(pickedPoint);
        beginTapFocusTransition(pickedPoint);
        tapFocusState.debug.successCount += 1;
        tapFocusState.debug.lastRejectedReason = '';
        tapFocusState.debug.lastFocusedPoint = {
            x: pickedPoint.x,
            y: pickedPoint.y,
            z: pickedPoint.z
        };
        return true;
    }

    // Screen-space tap radius so hit area scales with how big the dot appears (relative to view)
    function getTapDotScreenRadiusPx(tapDot) {
        const worldRadius = tapDotBaseSize * (tapDot.scale || 1);
        const distanceToCamera = camera.position.distanceTo(tapDot.dot.position);
        const halfFovRad = (camera.fov * Math.PI / 180) / 2;
        const projectedRadiusPx = (worldRadius / distanceToCamera) * (window.innerHeight / 2) / Math.tan(halfFovRad);
        return Math.max(projectedRadiusPx * tapRadiusMultiplier, 12);
    }

    function renderHiddenCanvas() {
        hiddenContext.clearRect(0, 0, hiddenCanvas.width, hiddenCanvas.height);
        getActiveTapDots().forEach((tapDot) => {
            let screenPos = tapDot.dot.position.clone().project(camera);
            let x = (screenPos.x + 1) / 2 * window.innerWidth;
            let y = -(screenPos.y - 1) / 2 * window.innerHeight;
            const screenRadiusPx = getTapDotScreenRadiusPx(tapDot);
            hiddenContext.fillStyle = tapDot.color;
            hiddenContext.beginPath();
            hiddenContext.arc(x, y, screenRadiusPx, 0, 2 * Math.PI);
            hiddenContext.fill();
        });
    }

    // Create "Sold" hotspots (optional overlay text)
    const soldHotspots = soldHotspotConfigurations.map((config) => createSoldHotspot(config));

    function calculateMaxDistance() {
        const aspectRatio = window.innerWidth / window.innerHeight;
        let additionalDistance = (1 / aspectRatio) * parameters.maxDistance.responsiveness;
        return parameters.maxDistance.base + additionalDistance;
    }

    function createBorderDot(dotData) {
        const { name, position } = dotData;
        let borderDotGeometry = new SphereGeometry(borderDotParams.radius, borderDotParams.widthSegments, borderDotParams.heightSegments);
        let borderDotMaterial = new MeshBasicMaterial({ color: borderDotParams.color, transparent: true, opacity: 0 });
        let borderDot = new Mesh(borderDotGeometry, borderDotMaterial);
        borderDot.scale.y = 0.1;
        borderDot.position.set(position.x, position.y, position.z);
        borderDot.userData.borderVertexName = name;
        scene.add(borderDot);
        return { name, mesh: borderDot };
    }

    // ***** ONLY THIS FUNCTION CHANGED TO REMOVE LENGTH-WISE ROLL *****
    function createBorderLineBetweenDots(dot1, dot2, lineOpacity = 0) {
        const start = dot1.position;
        const end = dot2.position;
        const direction = new Vector3().subVectors(end, start);
        const length = direction.length();
        const midPoint = new Vector3().addVectors(start, end).multiplyScalar(0.5);

        const boxThickness = borderDotParams.radius * 2;
        const boxHeight = 0.006;

        const boxGeometry = new BoxGeometry(length, boxHeight, boxThickness);
        const boxMaterial = new MeshBasicMaterial({ color: borderDotParams.color, transparent: true, opacity: lineOpacity });
        const box = new Mesh(boxGeometry, boxMaterial);

        // We define the local X axis as the direction of the line
        // and then fix the local Y/Z using a stable 'up' vector so we don't roll.
        let x = direction.clone().normalize();
        let up = new Vector3(0, 1, 0);

        // If direction is nearly parallel to world up, pick a different stable up
        if (Math.abs(x.dot(up)) > 0.9999) {
            up = new Vector3(0, 0, 1);
        }

        let z = new Vector3().crossVectors(x, up).normalize();
        let y = new Vector3().crossVectors(z, x).normalize();

        let rotMatrix = new Matrix4();
        // Create a rotation basis from x,y,z
        rotMatrix.makeBasis(x, y, z);

        // Position the box at the midpoint
        let translationMatrix = new Matrix4().makeTranslation(midPoint.x, midPoint.y, midPoint.z);

        box.matrixAutoUpdate = false;
        box.matrix.multiplyMatrices(translationMatrix, rotMatrix);

        scene.add(box);
        return box;
    }
    // ***** END CHANGE *****

    let fadeDuration = 5;
    let borderDotDelay = 0.9;
    let fadeStartTime = null;
    let borderLineFadeOpacity = 0;
    let borderDotFadeOpacity = 0;

    let borderDots = {};
    let borderLines = [];
    const borderDotsByHole = [];
    const borderLinesByHole = [];

    function getScreenPositionFromWorld(worldPosition) {
        const projected = worldPosition.clone().project(camera);
        return {
            x: (projected.x + 1) * 0.5 * window.innerWidth,
            y: (1 - projected.y) * 0.5 * window.innerHeight,
            visible: projected.z > -1 && projected.z < 1
        };
    }

    function borderConnectionKey(startName, endName) {
        return [startName, endName].sort().join('|');
    }

    function getConnectionIndex(connections, dots, startName, endName) {
        return connections.findIndex((connection) =>
            (connection.start === startName && connection.end === endName) ||
            (connection.start === endName && connection.end === startName)
        );
    }

    function dedupeBorderConnections(connections, dots) {
        const seen = new Set();
        const filtered = connections.filter((connection) => {
            if (!dots[connection.start] || !dots[connection.end]) return false;
            if (connection.start === connection.end) return false;
            const key = borderConnectionKey(connection.start, connection.end);
            if (seen.has(key)) return false;
            seen.add(key);
            return true;
        });
        connections.length = 0;
        connections.push(...filtered);
    }

    function getVisibleLineOpacity() {
        return lotEditState.active ? 1 : borderLineFadeOpacity;
    }

    function getVisibleDotOpacity() {
        return lotEditState.active ? 1 : borderDotFadeOpacity;
    }

    function refreshBorderVisualState() {
        const lotVisible = lotLinesConfig.visible !== false;
        const holes = lotLinesConfig && lotLinesConfig.holes;
        const showLotLines = lotVisible && (!holes || !Array.isArray(holes) || holes.length === 0 || (typeof activeHoleIndex !== 'undefined' && holes.includes(activeHoleIndex)));
        const dotOpacity = getVisibleDotOpacity();
        const selectedName = lotEditState.selectedVertexName;
        const mergeTargetName = lotEditState.dragging.mergeTargetName;
        tapDots.forEach((td) => {
            if (td.holeIndex !== activeHoleIndex) {
                td.dot.visible = false;
                td.iconMesh.visible = false;
            }
        });
        Object.entries(borderDots).forEach(([name, dotMesh]) => {
            dotMesh.visible = showLotLines;
            dotMesh.material.opacity = dotOpacity;
            dotMesh.material.color.setHex(borderDotParams.color);
            dotMesh.scale.set(1, 0.1, 1);
            if (lotEditState.active && name === mergeTargetName) {
                dotMesh.material.color.setHex(0xbf281b);
                dotMesh.scale.set(1.2, 0.12, 1.2);
            } else if (lotEditState.active && name === selectedName) {
                dotMesh.material.color.setHex(0xffffff);
                dotMesh.scale.set(1.25, 0.125, 1.25);
            }
        });
        const lineOpacity = getVisibleLineOpacity();
        borderLines.forEach((lineMesh) => {
            lineMesh.visible = showLotLines;
            lineMesh.material.opacity = lineOpacity;
            lineMesh.material.color.setHex(lotEditState.active ? 0xe8e8e8 : borderDotParams.color);
        });
        getActiveTapDots().forEach((tapDot) => {
            const showDot = tapDotsConfig.visible !== false && lotEditState.active;
            tapDot.dot.visible = showDot;
            tapDot.iconMesh.visible = showDot;
            if (showDot) {
                const baseScale = tapDot.scale || 1;
                const selectedTapDot = lotEditState.selectedTapDot;
                if (selectedTapDot === tapDot) {
                    tapDot.dot.material.color.setHex(0xffffff);
                    tapDot.dot.scale.setScalar(baseScale * 1.25);
                } else {
                    tapDot.dot.material.color.setHex(0x2C2C2E);
                    tapDot.dot.scale.setScalar(baseScale);
                }
            }
        });
    }

    function rebuildBorderLinesForHole(dots, connections, linesArray) {
        linesArray.forEach((lineMesh) => {
            scene.remove(lineMesh);
            lineMesh.geometry.dispose();
            lineMesh.material.dispose();
        });
        linesArray.length = 0;
        dedupeBorderConnections(connections, dots);
        connections.forEach((connection) => {
            const startDot = dots[connection.start];
            const endDot = dots[connection.end];
            if (!startDot || !endDot) return;
            const lineMesh = createBorderLineBetweenDots(startDot, endDot, getVisibleLineOpacity());
            lineMesh.userData.borderConnection = { start: connection.start, end: connection.end };
            linesArray.push(lineMesh);
        });
    }

    function rebuildBorderLines() {
        rebuildBorderLinesForHole(borderDots, borderLineConnections, borderLines);
        refreshBorderVisualState();
    }

    function setPointerFromEvent(event) {
        const bounds = renderer.domElement.getBoundingClientRect();
        lotEditState.pointerNDC.x = ((event.clientX - bounds.left) / bounds.width) * 2 - 1;
        lotEditState.pointerNDC.y = -((event.clientY - bounds.top) / bounds.height) * 2 + 1;
        lotEditState.dragRaycaster.setFromCamera(lotEditState.pointerNDC, camera);
    }

    function getPointerWorldOnPlane(event, planeY) {
        setPointerFromEvent(event);
        lotEditState.dragPlane.constant = -planeY;
        const intersection = new Vector3();
        const hit = lotEditState.dragRaycaster.ray.intersectPlane(lotEditState.dragPlane, intersection);
        return hit ? intersection : null;
    }

    function getBorderVertexHit(event) {
        setPointerFromEvent(event);
        const vertices = Object.values(borderDots);
        if (!vertices.length) return null;
        const intersections = lotEditState.dragRaycaster.intersectObjects(vertices, false);
        if (intersections.length) return intersections[0].object;

        let closestVertex = null;
        let closestDistance = Infinity;
        vertices.forEach((vertexMesh) => {
            const screen = getScreenPositionFromWorld(vertexMesh.position);
            if (!screen.visible) return;
            const distance = Math.hypot(screen.x - event.clientX, screen.y - event.clientY);
            if (distance < 11 && distance < closestDistance) {
                closestDistance = distance;
                closestVertex = vertexMesh;
            }
        });
        return closestVertex;
    }

    function getTapDotHit(event) {
        const active = getActiveTapDots();
        if (!active.length) return null;
        setPointerFromEvent(event);
        const tapDotMeshes = active.map((t) => t.dot);
        const intersections = lotEditState.dragRaycaster.intersectObjects(tapDotMeshes, false);
        if (intersections.length) {
            const hitMesh = intersections[0].object;
            return active.find((t) => t.dot === hitMesh) || null;
        }
        return null;
    }

    let borderLineConnections = [];
    const numHolesForBorders = Math.max(borderDotPositionsByHole?.length || 0, borderLineConnectionsByHole?.length || 0, 1);
    let nextBorderVertexId = 1;
    for (let hi = 0; hi < numHolesForBorders; hi++) {
        const positions = borderDotPositionsByHole[hi] || [];
        nextBorderVertexId = Math.max(nextBorderVertexId, positions.reduce((maxId, dotData) => {
            const id = parseInt(String(dotData.name).replace('Lot_V', ''), 10);
            return Number.isFinite(id) ? Math.max(maxId, id) : maxId;
        }, 0) + 1);
    }

    function getNextBorderVertexName() {
        while (borderDots[`Lot_V${nextBorderVertexId}`]) nextBorderVertexId++;
        const newName = `Lot_V${nextBorderVertexId}`;
        nextBorderVertexId++;
        return newName;
    }

    for (let holeIdx = 0; holeIdx < numHolesForBorders; holeIdx++) {
        const positions = borderDotPositionsByHole[holeIdx] || [];
        const connections = borderLineConnectionsByHole[holeIdx] || [];
        const holeDots = {};
        const holeLines = [];
        positions.forEach((dotData) => {
            const createdDot = createBorderDot(dotData);
            holeDots[createdDot.name] = createdDot.mesh;
        });
        borderDotsByHole[holeIdx] = holeDots;
        borderLinesByHole[holeIdx] = holeLines;
        rebuildBorderLinesForHole(holeDots, connections, holeLines);
    }
    borderDots = borderDotsByHole[0] || {};
    borderLines = borderLinesByHole[0] || [];
    borderLineConnections = borderLineConnectionsByHole[0] || [];

    function fadeInBorders(time) {
        if (!fadeStartTime) fadeStartTime = time;
        let elapsedTime = (time - fadeStartTime) / 1000;
        borderLineFadeOpacity = Math.min(elapsedTime / fadeDuration, 1);
        let dotElapsedTime = elapsedTime - borderDotDelay;
        borderDotFadeOpacity = Math.min(Math.max(dotElapsedTime / fadeDuration, 0), 1);
        refreshBorderVisualState();
        if (borderLineFadeOpacity < 1 || borderDotFadeOpacity < 1) {
            requestAnimationFrame(fadeInBorders);
        }
    }
    requestAnimationFrame(fadeInBorders);

    // "Sold" hotspot creation function
    // Identical to createHotspot except:
    // - No sphere is created
    // - The text color is orange (#FF4F40 here)
    // - We add a controllable verticalOffset (config.verticalOffset)
    function createSoldHotspot(config) {
        const { text, position, scale, verticalOffset } = config;

        // Create the text canvas (orange text, no sphere)
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 3072;
        canvas.height = 512;
        context.fillStyle = 'rgba(255, 255, 255, 0)';
        context.fillRect(0, 0, canvas.width, canvas.height);
        context.font = '520 250px "Helvetica Neue", Helvetica, Arial, sans-serif';
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.strokeStyle = 'rgba(0, 0, 0, 0.5)';
        context.lineWidth = 5;
        // Orange text fill:
        context.fillStyle = '#BF281B';
        context.fillText(text, canvas.width / 2, canvas.height / 2);
        context.strokeText(text, canvas.width / 2, canvas.height / 2);

        const texture = new Texture(canvas);
        texture.needsUpdate = true;
        const geometry = new PlaneGeometry(2.4, 0.4);
        const material = new MeshStandardMaterial({
            map: texture,
            transparent: false,
            alphaTest: 0.5,
            side: DoubleSide,
            premultipliedAlpha: true,
            emissive: '#BF281B',
            emissiveIntensity: 2,
        });

        const textPlane = new Mesh(geometry, material);
        // Position at the same center but allow a verticalOffset
        textPlane.position.set(position.x, position.y + (verticalOffset || 0), position.z);
        textPlane.rotation.y = MathUtils.degToRad(90);
        textPlane.scale.setScalar(scale);

        // You can further modify geometry translation if desired, but here we keep it minimal
        scene.add(textPlane);

        // Return something if we need to track it
        return { textPlane };
    }

    window.addEventListener('resize', function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio * 0.8, rendererPixelRatioCap));
        controls.maxDistance = Math.max(controls.minDistance + 0.01, getConfiguredMaxDistance(getActiveHoleConfig()));
        hiddenCanvas.width = window.innerWidth;
        hiddenCanvas.height = window.innerHeight;
        updateMidpointButtons();
    });

    const tempPathPosition = new Vector3();
    const tempPathLookAt = new Vector3();
    let lastAnimationFrameTime = performance.now();

    function sanitizePathVector(raw, fallback) {
        return {
            x: Number.isFinite(raw?.x) ? raw.x : fallback.x,
            y: Number.isFinite(raw?.y) ? raw.y : fallback.y,
            z: Number.isFinite(raw?.z) ? raw.z : fallback.z
        };
    }

    function buildCheckpointFromCurrentView(duration = 5) {
        return {
            position: {
                x: camera.position.x,
                y: camera.position.y,
                z: camera.position.z
            },
            lookAt: {
                x: controls.target.x,
                y: controls.target.y,
                z: controls.target.z
            },
            duration: Number.isFinite(duration) && duration > 0 ? duration : 5
        };
    }

    function sanitizePathCheckpoint(rawCheckpoint) {
        const baseCamera = parameters.camera.startPosition;
        const baseLookAt = parameters.scene.origin;
        const position = sanitizePathVector(rawCheckpoint?.position, baseCamera);
        const lookAt = sanitizePathVector(rawCheckpoint?.lookAt, baseLookAt);
        const duration = Number.isFinite(rawCheckpoint?.duration) && rawCheckpoint.duration > 0.1 ? rawCheckpoint.duration : 5;
        return { position, lookAt, duration };
    }

    function createPathAnimationStateForHole(holeIndex) {
        const holeConfig = holeConfigurations[holeIndex];
        const pathConfig = (holeConfig?.path === null ? parameters.animation.path : holeConfig?.path) || parameters.animation.path || {};
        const defaults = pathConfig;
        return {
            enabled: !!defaults.enabled,
            loop: defaults.loop !== false,
            speed: Number.isFinite(defaults.speed) && defaults.speed > 0 ? defaults.speed : 1,
            checkpoints: Array.isArray(defaults.checkpoints) ? defaults.checkpoints.map(sanitizePathCheckpoint) : [],
            playing: false,
            segmentIndex: 0,
            segmentElapsed: 0,
            lookAtOverrideAtStart: null
        };
    }
    const pathAnimationStateByHole = holeConfigurations.map((_, i) => createPathAnimationStateForHole(i));
    let pathAnimationState = pathAnimationStateByHole[0];

    function getPathSegmentCount() {
        const count = pathAnimationState.checkpoints.length;
        if (count < 2) return 0;
        return pathAnimationState.loop ? count : count - 1;
    }

    function getPathIndex(index) {
        const count = pathAnimationState.checkpoints.length;
        if (!count) return 0;
        if (pathAnimationState.loop) {
            return ((index % count) + count) % count;
        }
        return Math.min(Math.max(index, 0), count - 1);
    }

    function getPathCheckpoint(index) {
        return pathAnimationState.checkpoints[getPathIndex(index)];
    }

    function getPathDurationForSegment(segmentIndex) {
        const checkpoint = getPathCheckpoint(segmentIndex);
        if (!checkpoint) return 5;
        return Math.max(0.1, checkpoint.duration || 5);
    }

    function catmullRomScalar(p0, p1, p2, p3, t) {
        const t2 = t * t;
        const t3 = t2 * t;
        return 0.5 * (
            (2 * p1) +
            (-p0 + p2) * t +
            (2 * p0 - 5 * p1 + 4 * p2 - p3) * t2 +
            (-p0 + 3 * p1 - 3 * p2 + p3) * t3
        );
    }

    function catmullRomVector(v0, v1, v2, v3, t, out) {
        out.set(
            catmullRomScalar(v0.x, v1.x, v2.x, v3.x, t),
            catmullRomScalar(v0.y, v1.y, v2.y, v3.y, t),
            catmullRomScalar(v0.z, v1.z, v2.z, v3.z, t)
        );
        return out;
    }

    function applyPathCheckpoint(index) {
        const checkpoint = getPathCheckpoint(index);
        if (!checkpoint) return;
        camera.position.set(checkpoint.position.x, checkpoint.position.y, checkpoint.position.z);
        controls.target.set(checkpoint.lookAt.x, checkpoint.lookAt.y, checkpoint.lookAt.z);
        camera.lookAt(controls.target);
        controls.update();
    }

    function applyPathPose(segmentIndex, progress) {
        const checkpointCount = pathAnimationState.checkpoints.length;
        const segmentCount = getPathSegmentCount();
        if (!segmentCount || checkpointCount < 2) return;
        const clampedProgress = Math.min(Math.max(progress, 0), 1);
        const i1 = pathAnimationState.loop
            ? getPathIndex(segmentIndex)
            : Math.min(Math.max(segmentIndex, 0), checkpointCount - 2);
        const i2 = pathAnimationState.loop ? getPathIndex(i1 + 1) : Math.min(i1 + 1, checkpointCount - 1);
        const p0 = getPathCheckpoint(i1 - 1).position;
        const p1 = getPathCheckpoint(i1).position;
        const p2 = getPathCheckpoint(i2).position;
        const p3 = getPathCheckpoint(i2 + 1).position;
        const l0 = getPathCheckpoint(i1 - 1).lookAt;
        const l1 = getPathCheckpoint(i1).lookAt;
        const l2 = getPathCheckpoint(i2).lookAt;
        const l3 = getPathCheckpoint(i2 + 1).lookAt;
        catmullRomVector(p0, p1, p2, p3, clampedProgress, tempPathPosition);
        catmullRomVector(l0, l1, l2, l3, clampedProgress, tempPathLookAt);
        camera.position.copy(tempPathPosition);
        // Use primary focus lookAt at segment 0 start (animationStart mode)
        const override = pathAnimationState.lookAtOverrideAtStart;
        if (override && segmentIndex === 0 && clampedProgress < 0.02) {
            controls.target.set(override.x, override.y, override.z);
            if (clampedProgress >= 0.015) pathAnimationState.lookAtOverrideAtStart = null;  // Clear after brief hold
        } else {
            controls.target.copy(tempPathLookAt);
        }
        camera.lookAt(controls.target);
    }

    function updatePathAnimation(deltaSeconds) {
        if (!pathAnimationState.enabled || !pathAnimationState.playing) return;
        const segmentCount = getPathSegmentCount();
        if (!segmentCount) {
            pathAnimationState.playing = false;
            if (typeof syncAnimationEditorFromState === 'function') syncAnimationEditorFromState();
            return;
        }
        let endedPlayback = false;
        let remaining = Math.max(0, deltaSeconds * pathAnimationState.speed);
        while (remaining > 0 && pathAnimationState.playing) {
            const duration = getPathDurationForSegment(pathAnimationState.segmentIndex);
            const segmentRemaining = Math.max(0, duration - pathAnimationState.segmentElapsed);
            if (remaining < segmentRemaining) {
                pathAnimationState.segmentElapsed += remaining;
                remaining = 0;
                break;
            }
            remaining -= segmentRemaining;
            if (pathAnimationState.loop) {
                pathAnimationState.segmentIndex = (pathAnimationState.segmentIndex + 1) % segmentCount;
                pathAnimationState.segmentElapsed = 0;
                continue;
            }
            const lastSegment = segmentCount - 1;
            if (pathAnimationState.segmentIndex >= lastSegment) {
                pathAnimationState.segmentElapsed = getPathDurationForSegment(pathAnimationState.segmentIndex);
                pathAnimationState.playing = false;
                endedPlayback = true;
                remaining = 0;
                break;
            }
            pathAnimationState.segmentIndex += 1;
            pathAnimationState.segmentElapsed = 0;
        }
        const duration = getPathDurationForSegment(pathAnimationState.segmentIndex);
        const progress = duration > 0 ? Math.min(pathAnimationState.segmentElapsed / duration, 1) : 1;
        applyPathPose(pathAnimationState.segmentIndex, progress);
        if (endedPlayback && typeof syncAnimationEditorFromState === 'function') {
            setAnimationEditorStatus('End of path. Press Play to restart.');
            syncAnimationEditorFromState();
        }
    }

    function getSerializedCameraPathPayload() {
        const checkpoints = pathAnimationState.checkpoints.map((checkpoint) => ({
            position: {
                x: +checkpoint.position.x.toFixed(6),
                y: +checkpoint.position.y.toFixed(6),
                z: +checkpoint.position.z.toFixed(6)
            },
            lookAt: {
                x: +checkpoint.lookAt.x.toFixed(6),
                y: +checkpoint.lookAt.y.toFixed(6),
                z: +checkpoint.lookAt.z.toFixed(6)
            },
            duration: +Math.max(0.1, checkpoint.duration || 5).toFixed(3)
        }));
        return {
            enabled: !!pathAnimationState.enabled,
            loop: !!pathAnimationState.loop,
            speed: +Math.max(0.1, pathAnimationState.speed || 1).toFixed(3),
            checkpoints
        };
    }

    function syncSerializedPathToParameters() {
        const holeConfig = holeConfigurations[activeHoleIndex];
        if (holeConfig) {
            if (!holeConfig.path) holeConfig.path = { enabled: true, loop: true, speed: 1, checkpoints: [] };
            holeConfig.path = getSerializedCameraPathPayload();
        }
    }

    if (pathAnimationState.enabled && pathAnimationState.checkpoints.length) {
        applyPathCheckpoint(0);
        if (pathAnimationState.checkpoints.length > 1) {
            pathAnimationState.playing = true;
            autoRotate = false;
        }
    }

    // Enhanced compass logic with icon switching
    function getCompassRotation() {
        const target = controls.target;
        const cameraPos = camera.position;
        
        // Calculate the angle from target to camera (in XZ plane)
        const deltaX = cameraPos.x - target.x;
        const deltaZ = cameraPos.z - target.z;
        
        // Get angle in radians, then convert to degrees
        let cameraBearing = (Math.atan2(deltaX, deltaZ) * 180 / Math.PI + 360) % 360;
        
        // Calculate rotation needed to point arrow to configured north direction
        // Subtract camera bearing from north direction to get relative rotation
        let arrowRotation = (parameters.compass.northDirection - cameraBearing + 360) % 360;
        
        return arrowRotation;
    }

    function updateCompassIcon() {
        if (!compassIcon) return;
        
        const mode = (parameters.compass.northButtonMode || 'north').toLowerCase();
        const outlineIcon = 'https://raw.githubusercontent.com/HansenHomeAI/FigmaSVGButtons/main/NorthOutline.svg';
        const filledIcon = 'https://raw.githubusercontent.com/HansenHomeAI/FigmaSVGButtons/main/NorthFilled.svg';
        
        let targetSrc = outlineIcon;
        let iconRotation = 0;
        
        if (mode === 'animationstart') {
            // In animationStart mode: filled when at segment 0, arrow always points at primary focus
            const isAtAnimationStart = pathAnimationState.enabled && pathAnimationState.checkpoints.length >= 2
                && pathAnimationState.segmentIndex === 0;
            targetSrc = isAtAnimationStart ? filledIcon : outlineIcon;
            // Rotate arrow to always point at primary focus (hole target / tap dot)
            const primaryFocus = getPrimaryFocusPoint();
            const bearingToPrimary = (Math.atan2(primaryFocus.x - camera.position.x, primaryFocus.z - camera.position.z) * 180 / Math.PI + 360) % 360;
            const bearingToLookAt = (Math.atan2(controls.target.x - camera.position.x, controls.target.z - camera.position.z) * 180 / Math.PI + 360) % 360;
            iconRotation = (bearingToLookAt - bearingToPrimary + 360) % 360;
        } else {
            // North mode: filled when pointing at north
            const target = controls.target;
            const cameraPos = camera.position;
            const deltaX = cameraPos.x - target.x;
            const deltaZ = cameraPos.z - target.z;
            let cameraBearing = (Math.atan2(deltaX, deltaZ) * 180 / Math.PI + 360) % 360;
            iconRotation = (cameraBearing - parameters.compass.northDirection + 360) % 360;
            let bearingDifference = Math.abs(cameraBearing - parameters.compass.northDirection);
            if (bearingDifference > 180) bearingDifference = 360 - bearingDifference;
            const isPointingAtNorth = bearingDifference <= 15;
            targetSrc = isPointingAtNorth ? filledIcon : outlineIcon;
        }
        const currentSrc = compassIcon.src;
        
        // Switch icon if needed (check filename instead of full URL)
        const currentFilename = currentSrc.split('/').pop();
        const targetFilename = targetSrc.split('/').pop();
        
        if (currentFilename !== targetFilename) {
            compassIcon.src = targetSrc; // Direct switch for now, no animation
        }
        
        // Apply rotation - points to north (north mode) or primary focus (animationStart mode)
        compassIcon.style.transform = `rotate(${iconRotation}deg)`;
    }

    // Get primary focus point (hole view target or first tap dot)
    function getPrimaryFocusPoint() {
        const holeConfig = typeof getActiveHoleConfig === 'function' ? getActiveHoleConfig() : null;
        const viewTarget = holeConfig?.view?.target;
        if (viewTarget && Number.isFinite(viewTarget.x)) {
            return { x: viewTarget.x, y: viewTarget.y ?? parameters.scene.origin.y, z: viewTarget.z ?? parameters.scene.origin.z };
        }
        const activeTapDots = getActiveTapDots();
        if (activeTapDots && activeTapDots.length > 0) {
            const pos = activeTapDots[0].dot.position;
            return { x: pos.x, y: pos.y, z: pos.z };
        }
        return { ...parameters.scene.origin };
    }

    // Jump to animation path checkpoint 0 and start playing; camera faces primary focus (hole target / tap dot)
    function goToAnimationStart() {
        if (!pathAnimationState.enabled || !pathAnimationState.checkpoints.length) {
            if (typeof setAnimationEditorStatus === 'function') {
                setAnimationEditorStatus('No path checkpoints. Add checkpoints first.');
            }
            return;
        }
        if (pathAnimationState.checkpoints.length < 2) {
            if (typeof setAnimationEditorStatus === 'function') {
                setAnimationEditorStatus('Add 2+ checkpoints.');
            }
            return;
        }
        // Clear tap focus so animation uses its intended orbit/look-at points
        manualFocusTargetY = null;
        if (typeof tapFocusTransition !== 'undefined') {
            tapFocusTransition.active = false;
            tapFocusState.debug.transitionActive = false;
            tapFocusState.debug.transitionProgress = 0;
            tapFocusFeedback.active = false;
            tapFocusState.debug.feedbackActive = false;
            tapFocusState.debug.feedbackProgress = 0;
            if (tapFocusFeedbackEl) {
                tapFocusFeedbackEl.style.opacity = '0';
                tapFocusFeedbackEl.style.display = 'none';
            }
        }
        const primaryFocus = getPrimaryFocusPoint();
        pathAnimationState.lookAtOverrideAtStart = primaryFocus;
        pathAnimationState.segmentIndex = 0;
        pathAnimationState.segmentElapsed = 0;
        animationEditorState.selectedCheckpointIndex = 0;
        autoRotate = false;
        isAnimatingToNorth = false;
        // Apply checkpoint 0 position but look at primary focus (not north)
        const cp0 = getPathCheckpoint(0);
        if (cp0) {
            camera.position.set(cp0.position.x, cp0.position.y, cp0.position.z);
            controls.target.set(primaryFocus.x, primaryFocus.y, primaryFocus.z);
            camera.lookAt(controls.target);
            controls.update();
        }
        pathAnimationState.playing = true;
        ignoreNextPauseUntil = performance.now() + 150;
        if (typeof setAnimationEditorStatus === 'function') {
            setAnimationEditorStatus('Playing from start.');
        }
        if (typeof syncAnimationEditorFromState === 'function') {
            syncAnimationEditorFromState();
        }
    }

    // Smooth camera animation to face north
    function animateCameraToNorth() {
        if (isAnimatingToNorth) return; // Prevent multiple animations
        
        // Calculate target camera position to face north
        const target = controls.target;
        const currentRadius = camera.position.distanceTo(target);
        
        // Convert north direction to radians
        const northRadians = MathUtils.degToRad(parameters.compass.northDirection);
        
        // Calculate target position (camera looking toward north)
        targetCameraPosition.set(
            target.x + Math.sin(northRadians) * currentRadius,
            camera.position.y, // Keep same height
            target.z + Math.cos(northRadians) * currentRadius
        );
        
        // Store starting position
        startCameraPosition.copy(camera.position);
        
        // Start animation
        isAnimatingToNorth = true;
        animationStartTime = performance.now();
        autoRotate = false; // Disable auto-rotation during animation
        pathAnimationState.playing = false;
        if (typeof syncAnimationEditorFromState === 'function') {
            syncAnimationEditorFromState();
        }
        if (typeof setAnimationEditorStatus === 'function') {
            setAnimationEditorStatus('Paused path playback while rotating north.');
        }
        
    }

    // Smooth easing function (ease-out cubic)
    function easeOutCubic(t) {
        return 1 - Math.pow(1 - t, 3);
    }

    // Update camera animation in the main animation loop
    function updateCameraAnimation() {
        if (!isAnimatingToNorth) return;

        const elapsed = performance.now() - animationStartTime;
        const progress = Math.min(elapsed / animationDuration, 1);
        const easedProgress = easeOutCubic(progress);
        
        // Interpolate camera position
        camera.position.lerpVectors(startCameraPosition, targetCameraPosition, easedProgress);
        
        // Update controls target to maintain smooth interaction
        camera.lookAt(controls.target);
        
        // Animation complete
        if (progress >= 1) {
            isAnimatingToNorth = false;
        }
    }

    function animate(now = performance.now()) {
        const deltaSeconds = Math.min(Math.max((now - lastAnimationFrameTime) / 1000, 0), 0.1);
        lastAnimationFrameTime = now;
        if (!isAnimatingToNorth) {
            if (pathAnimationState.enabled && pathAnimationState.playing) {
                updatePathAnimation(deltaSeconds);
            } else if (autoRotate) {
                angle += parameters.animation.speed;
                const c = parameters.animation.center;
                camera.position.x = c.x + Math.sin(angle) * parameters.animation.startRadius;
                camera.position.z = c.z + Math.cos(angle) * parameters.animation.startRadius;
                camera.position.y = c.y + parameters.camera.startPosition.y;
                camera.lookAt(controls.target);
            }
        }

        // Make "Sold" hotspot text always face the camera
        soldHotspots.forEach(sold => {
            sold.textPlane.lookAt(camera.position);
        });

        getActiveTapDots().forEach(tapDot => {
            tapDot.iconMesh.lookAt(camera.position);
            let direction = new Vector3().subVectors(camera.position, tapDot.dot.position).normalize();
            let tapDotRadius = tapDotBaseSize * (tapDot.scale || 1);
            let offsetDistance = tapDotRadius + 0.02;
            tapDot.iconMesh.position.copy(tapDot.dot.position).add(direction.multiplyScalar(offsetDistance));
        });

        // Update 2D label overlay: project to screen, depth-sort, smooth position/opacity
        const labelsLayer = document.getElementById('tapdot-labels-layer');
        const labelsVisible = labelsLayer && tapDotsConfig.visible !== false && !window.isTapdotPopupOpen && !isDetailsOpen;
        if (labelsLayer) labelsLayer.style.display = labelsVisible ? 'block' : 'none';
        // Hide labels for tap dots belonging to other splats (they would otherwise persist at wrong screen position)
        tapDots.forEach(td => {
            if (td.labelEl) td.labelEl.style.display = td.holeIndex === activeHoleIndex ? '' : 'none';
        });
        if (labelsVisible) {
            const overlapPadding = 6;
            const opacityLerp = 0.18;
            const labelMaxDistance = 6;  /* hide label when camera is medium-far or farther */
            function rectsOverlap(a, b) {
                return !(a.right + overlapPadding <= b.left - overlapPadding ||
                    a.left - overlapPadding >= b.right + overlapPadding ||
                    a.bottom + overlapPadding <= b.top - overlapPadding ||
                    a.top - overlapPadding >= b.bottom + overlapPadding);
            }
            const labelsData = getActiveTapDots()
                .filter(td => td.labelEl && td.config.caption)
                .map(td => ({
                    tapDot: td,
                    screenPos: getScreenPositionFromWorld(td.dot.position),
                    distance: camera.position.distanceTo(td.dot.position)
                }))
                .filter(d => d.screenPos.visible && d.distance <= labelMaxDistance);
            const priorityOrder = { high: 0, medium: 1, low: 2 };
            labelsData.sort((a, b) => {
                const pa = priorityOrder[a.tapDot.config.priority] ?? 1;
                const pb = priorityOrder[b.tapDot.config.priority] ?? 1;
                if (pa !== pb) return pa - pb;
                return a.distance - b.distance;
            });
            const visibleRects = [];
            const snapThreshold = 40;
            const lerpMin = 0.02;
            const lerpMax = 0.55;
            labelsData.forEach(({ tapDot, screenPos }) => {
                const labelEl = tapDot.labelEl;
                const rawX = screenPos.x;
                const rawY = screenPos.y;
                let sx = tapDot._labelX;
                let sy = tapDot._labelY;
                if (sx === undefined) { sx = rawX; sy = rawY; }
                const dx = Math.abs(rawX - sx);
                const dy = Math.abs(rawY - sy);
                const delta = Math.hypot(dx, dy);
                let x, y;
                if (delta >= snapThreshold) {
                    x = rawX;
                    y = rawY;
                } else {
                    const t = delta / snapThreshold;
                    const lerp = lerpMin + (lerpMax - lerpMin) * t * t;
                    x = sx + (rawX - sx) * lerp;
                    y = sy + (rawY - sy) * lerp;
                }
                tapDot._labelX = x;
                tapDot._labelY = y;
                labelEl.style.left = x + 'px';
                labelEl.style.top = y + 'px';
                const br = labelEl.getBoundingClientRect();
                const rect = {
                    left: br.left,
                    right: br.right,
                    top: br.top,
                    bottom: br.bottom
                };
                const overlaps = visibleRects.some(v => rectsOverlap(rect, v));
                const targetOpacity = overlaps ? 0 : 1;
                let op = tapDot._labelOpacity;
                if (op === undefined) op = targetOpacity;
                tapDot._labelOpacity = op + (targetOpacity - op) * opacityLerp;
                labelEl.style.opacity = tapDot._labelOpacity;
                labelEl.style.pointerEvents = lotEditState.active ? 'auto' : 'none';
                if (!overlaps) visibleRects.push({ left: rect.left, right: rect.right, top: rect.top, bottom: rect.bottom });
            });
            const visibleTapDots = new Set(labelsData.map(d => d.tapDot));
            getActiveTapDots().forEach(td => {
                if (td.labelEl && !visibleTapDots.has(td)) {
                    let op = td._labelOpacity;
                    if (op === undefined) op = 0;
                    td._labelOpacity = op + (0 - op) * opacityLerp;
                    td.labelEl.style.opacity = td._labelOpacity;
                }
            });
        }

        // Update compass icon with smart switching and center rotation
        updateCompassIcon();

        // Update camera animation if active
        updateCameraAnimation();
        updateTapFocusTransition(now);
        updateTapFocusFeedback(now);

        // Min Y: sync orbit polar limit so floor is consistent at all distances
        const activeConfig = getActiveHoleConfig();
        const targetY = activeConfig?.view?.target?.y ?? parameters.scene.origin.y;
        const minYFromTarget = targetY + parameters.camera.minHeightAboveTarget;
        const minY = Math.max(parameters.camera.minY, minYFromTarget);
        const distance = camera.position.distanceTo(controls.target);
        const heightAboveTarget = minY - targetY;
        if (distance > 0.01 && heightAboveTarget > 0 && heightAboveTarget <= distance) {
            const polarForMinY = Math.acos(heightAboveTarget / distance);
            const polarForMinYDeg = MathUtils.radToDeg(polarForMinY);
            const penetrationDeg = 10;
            controls.maxPolarAngle = MathUtils.degToRad(Math.min(89, Math.max(30, polarForMinYDeg + penetrationDeg)));
        }

        controls.update();

        updateMidpointButtons();
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
    }

    function pauseCameraAutomationFromInteraction() {
        if (tapFocusTransition.active) {
            tapFocusTransition.active = false;
            tapFocusState.debug.transitionActive = false;
            tapFocusState.debug.transitionProgress = 1;
        }
        autoRotate = false;
        if (pathAnimationState.playing) {
            pathAnimationState.playing = false;
            if (typeof syncAnimationEditorFromState === 'function') {
                syncAnimationEditorFromState();
            }
            if (typeof setAnimationEditorStatus === 'function') {
                setAnimationEditorStatus('Paused camera path while manually navigating.');
            }
        }
    }

    let ignoreNextPauseUntil = 0;
    controls.addEventListener('start', () => {
        if (performance.now() < ignoreNextPauseUntil) return;
        pauseCameraAutomationFromInteraction();
    });
    window.addEventListener('touchstart', (e) => {
        if (e?.target?.closest?.('.menu-container, #compassButton, .hole-carousel, #detailsButton, #fullscreenButton')) return;
        if (performance.now() < ignoreNextPauseUntil) return;
        pauseCameraAutomationFromInteraction();
    });

    let lastPointerDownForTapDot = { x: 0, y: 0 };
    let suppressTapDotClickUntil = 0;
    const tapDotClickMoveThreshold = 10;
    window.addEventListener('pointerdown', (event) => {
        lastPointerDownForTapDot = { x: event.clientX, y: event.clientY };
    }, { passive: true });

    function handleTapDotActivation(event) {
        if (lotEditState.suppressNextClick) {
            lotEditState.suppressNextClick = false;
            return true;
        }
        if (lotEditState.active) return;
        if (window.isTapdotPopupOpen || isDetailsOpen) return;
        const eventTarget = event.target;
        if (eventTarget && eventTarget.closest && eventTarget.closest('#overlay-ui, .tapdot-popup, .details-box, .menu-container, .lot-editor-toggle-wrap, .lot-editor-panel, .lot-midpoint-plus, .editor-toggles-wrap, .animation-editor-panel, .splat-editor-panel')) return;
        const dx = event.clientX - lastPointerDownForTapDot.x;
        const dy = event.clientY - lastPointerDownForTapDot.y;
        if (Math.sqrt(dx * dx + dy * dy) > tapDotClickMoveThreshold) return;
        const x = Math.floor(event.clientX);
        const y = Math.floor(event.clientY);
        if (x < 0 || x >= hiddenCanvas.width || y < 0 || y >= hiddenCanvas.height) return;

        // Only allow tap activation when titles/labels are visible - no invisible hit areas
        const labelsLayer = document.getElementById('tapdot-labels-layer');
        if (!labelsLayer || labelsLayer.style.display === 'none') return false;
        const hasVisibleLabel = (td) => td.labelEl && td.config.caption && td._labelOpacity !== undefined && td._labelOpacity >= 0.01;

        try {
            renderHiddenCanvas();
            hiddenContext.getImageData(x, y, 1, 1);
        } catch (e) { return; }

        let closestDot = null;
        let closestDistance = Infinity;
        getActiveTapDots().forEach(tapDot => {
            if (!hasVisibleLabel(tapDot)) return;
            let screenPos = tapDot.dot.position.clone().project(camera);
            let dotX = (screenPos.x + 1) / 2 * window.innerWidth;
            let dotY = -(screenPos.y - 1) / 2 * window.innerHeight;
            const screenRadiusPx = getTapDotScreenRadiusPx(tapDot);
            let distance = Math.sqrt(Math.pow(dotX - x, 2) + Math.pow(dotY - y, 2));
            if (distance < closestDistance && distance < screenRadiusPx) {
                closestDot = tapDot;
                closestDistance = distance;
            }
        });

        if (closestDot) {
            showTapDotContent(closestDot);
            return true;
        }
        for (const tapDot of getActiveTapDots()) {
            if (!tapDot.labelEl || tapDot._labelOpacity === undefined || tapDot._labelOpacity < 0.01) continue;
            const br = tapDot.labelEl.getBoundingClientRect();
            if (x >= br.left && x <= br.right && y >= br.top && y <= br.bottom) {
                showTapDotContent(tapDot);
                return true;
            }
        }
        return false;
    }

    function wasTapAtSameSpot(event) {
        const dx = event.clientX - lastPointerDownForTapDot.x;
        const dy = event.clientY - lastPointerDownForTapDot.y;
        return Math.sqrt(dx * dx + dy * dy) <= tapDotClickMoveThreshold;
    }

    function isClickOn3DScene(event) {
        return event?.target === renderer.domElement;
    }
    window.addEventListener('click', (event) => {
        if (performance.now() < suppressTapDotClickUntil) return;
        const handledTapDot = handleTapDotActivation(event);
        if (!handledTapDot && wasTapAtSameSpot(event) && isClickOn3DScene(event)) focusCameraOnTappedPoint(event);
    });

    window.addEventListener('pointerup', (event) => {
        if (!event.isPrimary) return;
        if (event.pointerType !== 'touch' && event.pointerType !== 'pen') return;
        const handledTapDot = handleTapDotActivation(event);
        const focused = handledTapDot ? false : (wasTapAtSameSpot(event) && isClickOn3DScene(event) && focusCameraOnTappedPoint(event));
        if (handledTapDot || focused) suppressTapDotClickUntil = performance.now() + 700;
    }, { passive: true });

    window.addEventListener('touchend', (event) => {
        if ('PointerEvent' in window) return;
        if (!event.changedTouches || !event.changedTouches.length) return;
        const touch = event.changedTouches[0];
        const syntheticTapEvent = {
            clientX: touch.clientX,
            clientY: touch.clientY,
            target: event.target
        };
        const handledTapDot = handleTapDotActivation(syntheticTapEvent);
        const focused = handledTapDot ? false : (wasTapAtSameSpot(syntheticTapEvent) && isClickOn3DScene(syntheticTapEvent) && focusCameraOnTappedPoint(syntheticTapEvent));
        if (handledTapDot || focused) suppressTapDotClickUntil = performance.now() + 700;
    }, { passive: true });

    // Render loop is started above (no longer gated on icon load)

    // Hart Bench Ranch UI JavaScript - Ported with Extreme Care
    
    const detailsButton = document.getElementById('detailsButton');
    const fullscreenButton = document.getElementById('fullscreenButton');
    const compassButton = document.getElementById('compassButton');
    const compassIcon = document.getElementById('compassIcon');
    const holePrevButton = document.getElementById('holePrevButton');
    const holeNextButton = document.getElementById('holeNextButton');
    const holeLabelButton = document.getElementById('holeLabelButton');
    const holeCarousel = document.getElementById('holeCarousel');
    document.addEventListener('click', (e) => {
        const inCarousel = holeCarousel && holeCarousel.contains(e.target);
        if (!inCarousel) return;
        const prev = e.target.closest('#holePrevButton');
        const next = e.target.closest('#holeNextButton');
        const label = e.target.closest('#holeLabelButton');
        if (prev && !prev.disabled) cycleHole(-1);
        else if ((next || label) && (!next || !next.disabled)) cycleHole(1);
    }, true);
    const detailsBox = document.getElementById('detailsBox');
    const overlayUI = document.getElementById('overlay-ui');
    const detailsContent = document.getElementById('detailsContent');
    const customThumb = document.getElementById('customThumb');
    const customScrollbar = document.getElementById('customScrollbar');
    const detailsInner = document.getElementById('detailsInner');
    const menuContainer = document.getElementById('menuContainer');
    const lotEditorToggle = document.getElementById('lotEditorToggle');
    const lotEditorPanel = document.getElementById('lotEditorPanel');
    const lotEditorStatus = document.getElementById('lotEditorStatus');
    const lotEditorVertexName = document.getElementById('lotEditorVertexName');
    const lotVertexXInput = document.getElementById('lotVertexXInput');
    const lotVertexYInput = document.getElementById('lotVertexYInput');
    const lotVertexZInput = document.getElementById('lotVertexZInput');
    const lotCopyJsonButton = document.getElementById('lotCopyJsonButton');
    const lotMidpointLayer = document.getElementById('lotMidpointLayer');
    const animationEditorToggleWrap = document.getElementById('animationEditorToggleWrap');
    const animationEditorToggle = document.getElementById('animationEditorToggle');
    const animationEditorPanel = document.getElementById('animationEditorPanel');
    const animationEditorCloseButton = document.getElementById('animationEditorCloseButton');
    const animationEditorStatus = document.getElementById('animationEditorStatus');
    const animationEditorSummary = document.getElementById('animationEditorSummary');
    const animationCheckpointStrip = document.getElementById('animationCheckpointStrip');
    const animationCaptureCheckpointButton = document.getElementById('animationCaptureCheckpointButton');
    const animationPlayToggleButton = document.getElementById('animationPlayToggleButton');
    const animationExportButton = document.getElementById('animationExportButton');
    const splatEditorToggleWrap = document.getElementById('splatEditorToggleWrap');
    const splatEditorToggle = document.getElementById('splatEditorToggle');
    const splatEditorPanel = document.getElementById('splatEditorPanel');
    const splatEditorCloseButton = document.getElementById('splatEditorCloseButton');
    const splatEditorStatus = document.getElementById('splatEditorStatus');
    const splatPosX = document.getElementById('splatPosX');
    const splatPosY = document.getElementById('splatPosY');
    const splatPosZ = document.getElementById('splatPosZ');
    const splatRotX = document.getElementById('splatRotX');
    const splatRotY = document.getElementById('splatRotY');
    const splatRotZ = document.getElementById('splatRotZ');
    const splatScale = document.getElementById('splatScale');
    const splatExportButton = document.getElementById('splatExportButton');
    const tapDotGithubRawBase = 'https://raw.githubusercontent.com/HansenHomeAI/Red-Arrow-Ranch/main/3D%20Model%20Folders';

    let isDetailsOpen = false;
    let isAnimatingToNorth = false;
    const splatEditorState = {
        enabled: !!(parameters.splatEditor && parameters.splatEditor.enabled),
        open: false
    };

    const editorTogglesWrap = document.getElementById('editorTogglesWrap');
    if (editorTogglesWrap) {
        editorTogglesWrap.style.display = parameters.developerToolsVisible ? 'flex' : 'none';
    }

    function resolveTapDotPhotoUrl(photoSrc) {
        if (!photoSrc) return '';
        if (/^(?:[a-z]+:)?\/\//i.test(photoSrc) || photoSrc.startsWith('data:') || photoSrc.startsWith('blob:')) {
            return photoSrc;
        }
        const normalized = String(photoSrc).replace(/\\/g, '/').replace(/^\.?\//, '');
        if (normalized.startsWith('3D Model Folders/')) {
            const relativePath = normalized.slice('3D Model Folders/'.length);
            const encodedPath = relativePath.split('/').map((segment) => encodeURIComponent(segment)).join('/');
            return `${tapDotGithubRawBase}/${encodedPath}`;
        }
        try {
            return new URL(normalized, window.location.href).href;
        } catch (error) {
            return normalized;
        }
    }

    let isDraggingThumb = false;
    let dragStartY = 0;
    let startScrollTop = 0;
    let scrollbarFadeTimeout;
    let animationStartTime = 0;
    let startCameraPosition = new Vector3();
    let targetCameraPosition = new Vector3();
    const animationDuration = 1500; // 1.5 seconds
    const animationEditorState = {
        enabled: !!(parameters.animation.editor && parameters.animation.editor.enabled),
        open: false,
        selectedCheckpointIndex: 0,
        lastExportJson: ''
    };

    setActiveHole(0, { resetCamera: true });

    function setAnimationEditorStatus(message) {
        if (animationEditorStatus) {
            animationEditorStatus.textContent = message;
        }
    }

    function getSelectedPathCheckpoint() {
        const index = animationEditorState.selectedCheckpointIndex;
        return pathAnimationState.checkpoints[index] || null;
    }

    function getTotalPathSeconds() {
        const checkpoints = pathAnimationState.checkpoints;
        const count = checkpoints.length;
        if (!count) return 0;
        if (count === 1) return Math.max(0.1, checkpoints[0].duration || 5);
        const finalIndex = pathAnimationState.loop ? count : count - 1;
        let total = 0;
        for (let i = 0; i < finalIndex; i++) {
            total += Math.max(0.1, checkpoints[i].duration || 5);
        }
        return total;
    }

    function syncSelectedCheckpointIndex() {
        const count = pathAnimationState.checkpoints.length;
        if (!count) {
            animationEditorState.selectedCheckpointIndex = 0;
            return;
        }
        animationEditorState.selectedCheckpointIndex = Math.min(
            Math.max(animationEditorState.selectedCheckpointIndex, 0),
            count - 1
        );
    }

    function deleteCheckpointAtIndex(index) {
        if (!pathAnimationState.checkpoints.length || index < 0 || index >= pathAnimationState.checkpoints.length) return;
        pathAnimationState.playing = false;
        pathAnimationState.checkpoints.splice(index, 1);
        animationEditorState.selectedCheckpointIndex = Math.min(
            Math.max(animationEditorState.selectedCheckpointIndex, 0),
            Math.max(0, pathAnimationState.checkpoints.length - 1)
        );
        setAnimationEditorStatus(`Deleted checkpoint ${index + 1}.`);
        syncAnimationEditorFromState();
    }

    function overwriteCheckpointAtIndex(index) {
        if (!pathAnimationState.checkpoints.length || index < 0 || index >= pathAnimationState.checkpoints.length) return;
        const existing = pathAnimationState.checkpoints[index];
        const duration = existing ? Math.max(0.1, existing.duration || 5) : 5;
        const checkpoint = buildCheckpointFromCurrentView(duration);
        pathAnimationState.playing = false;
        pathAnimationState.checkpoints[index] = checkpoint;
        setAnimationEditorStatus(`Overwrote checkpoint ${index + 1}.`);
        syncAnimationEditorFromState();
        syncAnimationEditorFromState();
    }

    function renderAnimationCheckpointStrip() {
        if (!animationCheckpointStrip) return;
        const checkpoints = pathAnimationState.checkpoints;
        animationCheckpointStrip.innerHTML = '';
        const fragment = document.createDocumentFragment();

        checkpoints.forEach((checkpoint, index) => {
            const item = document.createElement('div');
            item.className = 'animation-checkpoint-item';

            const hoverActions = document.createElement('div');
            hoverActions.className = 'animation-checkpoint-hover-actions';
            const deleteBtn = document.createElement('button');
            deleteBtn.type = 'button';
            deleteBtn.className = 'animation-checkpoint-delete-btn';
            deleteBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2M10 11v6M14 11v6"/></svg>';
            deleteBtn.setAttribute('aria-label', `Delete checkpoint ${index + 1}`);
            deleteBtn.title = 'Delete';
            const overwriteBtn = document.createElement('button');
            overwriteBtn.type = 'button';
            overwriteBtn.className = 'animation-checkpoint-overwrite-btn';
            overwriteBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>';
            overwriteBtn.setAttribute('aria-label', `Overwrite checkpoint ${index + 1} with current view`);
            overwriteBtn.title = 'Overwrite';
            hoverActions.appendChild(deleteBtn);
            hoverActions.appendChild(overwriteBtn);

            const pill = document.createElement('div');
            pill.className = 'animation-checkpoint-pill';
            if (index === animationEditorState.selectedCheckpointIndex) {
                pill.classList.add('active');
            }
            if (pathAnimationState.playing && index === getPathIndex(pathAnimationState.segmentIndex)) {
                pill.classList.add('playing');
            }
            pill.innerHTML = `<span class="animation-checkpoint-pill-label">${index + 1}</span>`;
            pill.title = `Checkpoint ${index + 1} — click to view`;
            pill.setAttribute('role', 'button');
            pill.setAttribute('tabindex', '0');
            pill.setAttribute('aria-label', `Go to checkpoint ${index + 1}`);

            const activate = () => {
                animationEditorState.selectedCheckpointIndex = index;
                goToSelectedCheckpoint();
            };
            pill.addEventListener('click', () => activate());
            pill.addEventListener('keydown', (event) => {
                if (event.key === 'Enter' || event.key === ' ') {
                    event.preventDefault();
                    activate();
                }
            });

            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                deleteCheckpointAtIndex(index);
            });
            overwriteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                overwriteCheckpointAtIndex(index);
            });

            item.appendChild(pill);
            item.appendChild(hoverActions);
            fragment.appendChild(item);
        });

        animationCheckpointStrip.appendChild(fragment);
    }

    function syncAnimationEditorFromState() {
        if (!animationEditorState.enabled || !animationEditorPanel) return;
        syncSelectedCheckpointIndex();
        const checkpointCount = pathAnimationState.checkpoints.length;
        const totalSeconds = getTotalPathSeconds();
        if (animationEditorSummary) {
            if (!checkpointCount) {
                animationEditorSummary.textContent = '0';
            } else {
                animationEditorSummary.textContent = `${checkpointCount} • ${totalSeconds.toFixed(1)}s`;
            }
        }
        if (animationCaptureCheckpointButton) animationCaptureCheckpointButton.disabled = false;
        if (animationPlayToggleButton) {
            const playSvg = animationPlayToggleButton.querySelector('.icon-play');
            const pauseSvg = animationPlayToggleButton.querySelector('.icon-pause');
            if (playSvg) playSvg.style.display = pathAnimationState.playing ? 'none' : 'block';
            if (pauseSvg) pauseSvg.style.display = pathAnimationState.playing ? 'block' : 'none';
            animationPlayToggleButton.setAttribute('aria-label', pathAnimationState.playing ? 'Pause' : 'Play');
            animationPlayToggleButton.disabled = checkpointCount < 2;
        }
        renderAnimationCheckpointStrip();
        syncSerializedPathToParameters();
        window.__cameraAnimationPath = getSerializedCameraPathPayload();
    }

    function setAnimationEditorOpen(enabled) {
        if (!animationEditorState.enabled || !animationEditorPanel || !animationEditorToggle) return;
        animationEditorState.open = !!enabled;
        animationEditorPanel.classList.toggle('active', animationEditorState.open);
        animationEditorToggle.classList.toggle('active', animationEditorState.open);
        animationEditorToggle.setAttribute('aria-pressed', animationEditorState.open ? 'true' : 'false');
    }

    function setPathAnimationEnabled(enabled) {
        pathAnimationState.enabled = !!enabled;
        if (!pathAnimationState.enabled) {
            pathAnimationState.playing = false;
            autoRotate = !!parameters.animation.autoRotate;
            setAnimationEditorStatus('Paused. Capture to add.');
        } else if (pathAnimationState.checkpoints.length > 1) {
            autoRotate = false;
            setAnimationEditorStatus('Ready. Press Play.');
        } else {
            pathAnimationState.playing = false;
            setAnimationEditorStatus('Add 2+ checkpoints to play.');
        }
        syncAnimationEditorFromState();
    }

    function captureCheckpointFromCurrentView() {
        pathAnimationState.playing = false;
        const checkpoints = pathAnimationState.checkpoints;
        const selectedIdx = animationEditorState.selectedCheckpointIndex;
        const selected = getSelectedPathCheckpoint();
        const nextDuration = selected ? Math.max(0.1, selected.duration || 5) : 5;
        const checkpoint = buildCheckpointFromCurrentView(nextDuration);
        const insertAt = checkpoints.length > 0 && selectedIdx >= 0 && selectedIdx < checkpoints.length
            ? selectedIdx + 1
            : checkpoints.length;
        checkpoints.splice(insertAt, 0, checkpoint);
        animationEditorState.selectedCheckpointIndex = insertAt;
        const statusMsg = checkpoints.length === 1
            ? `Captured checkpoint 1.`
            : `Captured checkpoint ${insertAt + 1} (inserted after ${selectedIdx + 1}).`;
        setAnimationEditorStatus(statusMsg);
        syncAnimationEditorFromState();
    }

    function goToSelectedCheckpoint(showStatus = true) {
        if (!pathAnimationState.checkpoints.length) return;
        pathAnimationState.playing = false;
        pathAnimationState.segmentElapsed = 0;
        pathAnimationState.segmentIndex = animationEditorState.selectedCheckpointIndex;
        applyPathCheckpoint(animationEditorState.selectedCheckpointIndex);
        if (showStatus) {
            setAnimationEditorStatus(`Jumped to checkpoint ${animationEditorState.selectedCheckpointIndex + 1}.`);
        }
        syncAnimationEditorFromState();
    }

    function togglePathPlayback() {
        if (!pathAnimationState.enabled) {
            setPathAnimationEnabled(true);
        }
        if (pathAnimationState.checkpoints.length < 2) {
            pathAnimationState.playing = false;
            setAnimationEditorStatus('Add 2+ checkpoints.');
            syncAnimationEditorFromState();
            return;
        }
        if (pathAnimationState.playing) {
            pathAnimationState.playing = false;
            setAnimationEditorStatus('Paused.');
            syncAnimationEditorFromState();
            return;
        }
        const segmentCount = getPathSegmentCount();
        if (!segmentCount) {
            setAnimationEditorStatus('Add checkpoints first.');
            syncAnimationEditorFromState();
            return;
        }
        manualFocusTargetY = null;
        if (typeof tapFocusTransition !== 'undefined') {
            tapFocusTransition.active = false;
            tapFocusFeedback.active = false;
            if (tapFocusFeedbackEl) {
                tapFocusFeedbackEl.style.opacity = '0';
                tapFocusFeedbackEl.style.display = 'none';
            }
        }
        ignoreNextPauseUntil = performance.now() + 150;
        autoRotate = false;
        isAnimatingToNorth = false;
        if (!pathAnimationState.loop && animationEditorState.selectedCheckpointIndex >= pathAnimationState.checkpoints.length - 1) {
            animationEditorState.selectedCheckpointIndex = 0;
        }
        pathAnimationState.segmentIndex = pathAnimationState.loop
            ? getPathIndex(animationEditorState.selectedCheckpointIndex)
            : Math.min(animationEditorState.selectedCheckpointIndex, pathAnimationState.checkpoints.length - 2);
        pathAnimationState.segmentElapsed = 0;
        pathAnimationState.playing = true;
        applyPathPose(pathAnimationState.segmentIndex, 0);
        setAnimationEditorStatus('Playing.');
        syncAnimationEditorFromState();
    }

    function buildCameraPathExportSnippet() {
        const payload = getSerializedCameraPathPayload();
        const jsonText = JSON.stringify(payload, null, 2);
        return {
            payload,
            jsonText,
            snippet: `path: ${jsonText}`
        };
    }

    async function exportCameraPathToClipboard() {
        const { payload, snippet } = buildCameraPathExportSnippet();
        animationEditorState.lastExportJson = snippet;
        window.__cameraAnimationExport = snippet;
        try {
            const copied = await copyTextToClipboard(snippet);
            if (copied) {
                setAnimationEditorStatus(`Copied ${payload.checkpoints.length} checkpoints (${getTotalPathSeconds().toFixed(2)}s total).`);
                return;
            }
        } catch (error) {
            // Fall through to prompt fallback.
        }
        try {
            window.prompt('Copy camera path config', snippet);
            setAnimationEditorStatus(`Path JSON ready (${payload.checkpoints.length} checkpoints).`);
        } catch (error) {
            setAnimationEditorStatus('Unable to copy camera path JSON automatically.');
        }
    }

    function initializeAnimationEditor() {
        if (!animationEditorState.enabled) {
            if (animationEditorToggleWrap) animationEditorToggleWrap.style.display = 'none';
            if (animationEditorPanel) animationEditorPanel.style.display = 'none';
            return;
        }
        if (!animationEditorPanel || !animationEditorToggle) return;
        pathAnimationState.loop = true;
        pathAnimationState.speed = 1;
        setAnimationEditorOpen(!!(parameters.animation.editor && parameters.animation.editor.defaultOpen));
        setAnimationEditorStatus('Capture to add. Click pill to view. Hover pill for Delete/Overwrite.');
        syncAnimationEditorFromState();
        window.__syncAnimationEditorUI = syncAnimationEditorFromState;
        window.__cameraPathDebug = {
            getState: () => ({
                enabled: pathAnimationState.enabled,
                loop: pathAnimationState.loop,
                speed: pathAnimationState.speed,
                playing: pathAnimationState.playing,
                selectedCheckpointIndex: animationEditorState.selectedCheckpointIndex,
                checkpointCount: pathAnimationState.checkpoints.length,
                segmentIndex: pathAnimationState.segmentIndex,
                segmentElapsed: pathAnimationState.segmentElapsed
            }),
            getCamera: () => ({
                position: {
                    x: camera.position.x,
                    y: camera.position.y,
                    z: camera.position.z
                },
                target: {
                    x: controls.target.x,
                    y: controls.target.y,
                    z: controls.target.z
                }
            }),
            getSerializedPath: () => getSerializedCameraPathPayload()
        };
    }

    function setSplatEditorOpen(open) {
        if (!splatEditorState.enabled || !splatEditorPanel || !splatEditorToggle) return;
        splatEditorState.open = !!open;
        splatEditorPanel.classList.toggle('active', splatEditorState.open);
        splatEditorToggle.classList.toggle('active', splatEditorState.open);
        splatEditorToggle.setAttribute('aria-pressed', splatEditorState.open ? 'true' : 'false');
        if (splatEditorState.open) syncSplatEditorFromConfig();
    }

    function syncSplatEditorFromConfig() {
        if (!splatEditorState.enabled || !splatEditorPanel) return;
        const config = getActiveHoleConfig();
        if (!config || !config.splat) return;
        const s = config.splat;
        const pos = s.position || { x: 0, y: 0, z: 0 };
        const rot = s.rotation || { x: 0, y: 0, z: 0 };
        const scaleVal = Number.isFinite(s.scale) ? s.scale : 1;
        if (splatPosX) splatPosX.value = pos.x;
        if (splatPosY) splatPosY.value = pos.y;
        if (splatPosZ) splatPosZ.value = pos.z;
        if (splatRotX) splatRotX.value = rot.x;
        if (splatRotY) splatRotY.value = rot.y;
        if (splatRotZ) splatRotZ.value = rot.z;
        if (splatScale) splatScale.value = scaleVal;
        if (splatEditorStatus) splatEditorStatus.textContent = 'Editing: ' + (getActiveHoleConfig()?.label || 'Hole 15');
    }

    function applySplatEditorToConfig() {
        const config = getActiveHoleConfig();
        if (!config) return;
        if (!config.splat) config.splat = { position: { x: 0, y: 0, z: 0 }, rotation: { x: 0, y: 0, z: 0 }, scale: 1 };
        const pos = parseFloat(splatPosX?.value) || 0;
        const posY = parseFloat(splatPosY?.value) || 0;
        const posZ = parseFloat(splatPosZ?.value) || 0;
        const rotX = parseFloat(splatRotX?.value) || 0;
        const rotY = parseFloat(splatRotY?.value) || 0;
        const rotZ = parseFloat(splatRotZ?.value) || 0;
        const scaleVal = parseFloat(splatScale?.value);
        config.splat.position = { x: pos, y: posY, z: posZ };
        config.splat.rotation = { x: rotX, y: rotY, z: rotZ };
        config.splat.scale = Number.isFinite(scaleVal) && scaleVal > 0 ? scaleVal : 1;
        const holeSplat = holeSplats[activeHoleIndex];
        if (holeSplat) applyHoleSplatTransform(holeSplat, config);
    }

    function getSplatExportPayload() {
        applySplatEditorToConfig();
        const config = getActiveHoleConfig();
        if (!config || !config.splat) return null;
        const s = config.splat;
        return {
            position: { x: +(s.position?.x ?? 0), y: +(s.position?.y ?? 0), z: +(s.position?.z ?? 0) },
            rotation: { x: +(s.rotation?.x ?? 0), y: +(s.rotation?.y ?? 0), z: +(s.rotation?.z ?? 0) },
            scale: Number.isFinite(s.scale) ? s.scale : 1
        };
    }

    function initializeSplatEditor() {
        if (!splatEditorState.enabled) {
            if (splatEditorToggleWrap) splatEditorToggleWrap.style.display = 'none';
            if (splatEditorPanel) splatEditorPanel.style.display = 'none';
            return;
        }
        if (!splatEditorPanel || !splatEditorToggle) return;
        setSplatEditorOpen(!!(parameters.splatEditor && parameters.splatEditor.defaultOpen));
        syncSplatEditorFromConfig();
    }

    function setLotEditorStatus(message) {
        if (lotEditorStatus) lotEditorStatus.textContent = message;
    }

    function setLotEditorInputsEnabled(enabled) {
        [lotVertexXInput, lotVertexYInput, lotVertexZInput].forEach((input) => {
            if (!input) return;
            input.disabled = !enabled;
        });
    }

    function syncLotEditorInputsFromSelection() {
        const selectedName = lotEditState.selectedVertexName;
        const selectedTapDot = lotEditState.selectedTapDot;
        if (selectedTapDot) {
            const pos = selectedTapDot.dot.position;
            lotEditorVertexName.textContent = `Tap dot: ${selectedTapDot.config.caption || selectedTapDot.config.icon || 'Tap dot'}`;
            lotVertexXInput.value = pos.x.toFixed(6);
            lotVertexYInput.value = pos.y.toFixed(6);
            lotVertexZInput.value = pos.z.toFixed(6);
            setLotEditorInputsEnabled(true);
            return;
        }
        const selectedMesh = selectedName ? borderDots[selectedName] : null;
        if (!selectedMesh) {
            lotEditorVertexName.textContent = 'Vertex: none selected';
            lotVertexXInput.value = '';
            lotVertexYInput.value = '';
            lotVertexZInput.value = '';
            setLotEditorInputsEnabled(false);
            return;
        }
        lotEditorVertexName.textContent = `Vertex: ${selectedName}`;
        lotVertexXInput.value = selectedMesh.position.x.toFixed(6);
        lotVertexYInput.value = selectedMesh.position.y.toFixed(6);
        lotVertexZInput.value = selectedMesh.position.z.toFixed(6);
        setLotEditorInputsEnabled(true);
    }

    function selectTapDot(tapDot) {
        if (!tapDot) {
            lotEditState.selectedTapDot = null;
            syncLotEditorInputsFromSelection();
            refreshBorderVisualState();
            return;
        }
        lotEditState.selectedVertexName = null;
        lotEditState.selectedTapDot = tapDot;
        syncLotEditorInputsFromSelection();
        refreshBorderVisualState();
    }

    function selectBorderVertex(vertexName) {
        if (!vertexName || !borderDots[vertexName]) {
            lotEditState.selectedVertexName = null;
            lotEditState.selectedTapDot = null;
            syncLotEditorInputsFromSelection();
            refreshBorderVisualState();
            return;
        }
        lotEditState.selectedVertexName = vertexName;
        lotEditState.selectedTapDot = null;
        syncLotEditorInputsFromSelection();
        refreshBorderVisualState();
    }

    function getLotEditorTopDownHeight() {
        const dots = Object.values(borderDots);
        if (!dots.length) return 2.4;
        let minX = Infinity;
        let maxX = -Infinity;
        let minZ = Infinity;
        let maxZ = -Infinity;
        dots.forEach((dotMesh) => {
            minX = Math.min(minX, dotMesh.position.x);
            maxX = Math.max(maxX, dotMesh.position.x);
            minZ = Math.min(minZ, dotMesh.position.z);
            maxZ = Math.max(maxZ, dotMesh.position.z);
        });
        const span = Math.max(maxX - minX, maxZ - minZ, 1);
        return Math.max(1.8, span * 2.2);
    }

    function alignCameraToLotEditorView() {
        const target = controls.target.clone();
        const northRadians = MathUtils.degToRad(parameters.compass.northDirection);
        const northVector = new Vector3(Math.sin(northRadians), 0, Math.cos(northRadians)).normalize();
        camera.position.set(target.x, target.y + getLotEditorTopDownHeight(), target.z + 0.0001);
        camera.up.copy(northVector);
        camera.lookAt(target);
        controls.update();
    }

    function clearMidpointButtons() {
        lotEditState.midpointButtons.forEach((button) => button.remove());
        lotEditState.midpointButtons.clear();
    }

    function updateMidpointButtons() {
        if (!lotEditState.active || lotLinesConfig.visible === false) {
            clearMidpointButtons();
            return;
        }

        const candidates = [];
        borderLineConnections.forEach((connection) => {
            const startDot = borderDots[connection.start];
            const endDot = borderDots[connection.end];
            if (!startDot || !endDot) return;
            const startScreen = getScreenPositionFromWorld(startDot.position);
            const endScreen = getScreenPositionFromWorld(endDot.position);
            if (!startScreen.visible || !endScreen.visible) return;
            const dx = endScreen.x - startScreen.x;
            const dy = endScreen.y - startScreen.y;
            const distance = Math.hypot(dx, dy);
            if (distance < lotEditState.midpointMinScreenDistancePx) return;
            candidates.push({
                key: borderConnectionKey(connection.start, connection.end),
                start: connection.start,
                end: connection.end,
                x: (startScreen.x + endScreen.x) * 0.5,
                y: (startScreen.y + endScreen.y) * 0.5,
                distance
            });
        });

        candidates.sort((a, b) => b.distance - a.distance);
        const selected = [];
        for (const candidate of candidates) {
            if (selected.length >= lotEditState.midpointMaxButtons) break;
            const hasNearby = selected.some((placed) => {
                const dx = placed.x - candidate.x;
                const dy = placed.y - candidate.y;
                return Math.hypot(dx, dy) < lotEditState.midpointMinSpacingPx;
            });
            if (!hasNearby) selected.push(candidate);
        }

        const activeKeys = new Set(selected.map((entry) => entry.key));
        lotEditState.midpointButtons.forEach((button, key) => {
            if (!activeKeys.has(key)) {
                button.remove();
                lotEditState.midpointButtons.delete(key);
            }
        });

        selected.forEach((entry) => {
            let button = lotEditState.midpointButtons.get(entry.key);
            if (!button) {
                button = document.createElement('button');
                button.type = 'button';
                button.className = 'lot-midpoint-plus';
                button.textContent = '+';
                button.addEventListener('click', (event) => {
                    event.preventDefault();
                    event.stopPropagation();
                    insertVertexAtConnection(button.dataset.start, button.dataset.end);
                });
                lotEditState.midpointButtons.set(entry.key, button);
                lotMidpointLayer.appendChild(button);
            }
            button.dataset.start = entry.start;
            button.dataset.end = entry.end;
            button.style.left = `${entry.x}px`;
            button.style.top = `${entry.y}px`;
        });
    }

    function getConnectionCountForVertex(vertexName) {
        return borderLineConnections.reduce((count, connection) => {
            return count + ((connection.start === vertexName || connection.end === vertexName) ? 1 : 0);
        }, 0);
    }

    function getSerializedBorderDotPositions() {
        return Object.entries(borderDots)
            .map(([name, dotMesh]) => ({
                name,
                position: {
                    x: +dotMesh.position.x.toFixed(6),
                    y: +dotMesh.position.y.toFixed(6),
                    z: +dotMesh.position.z.toFixed(6)
                }
            }))
            .sort((a, b) => {
                const aIndex = parseInt(String(a.name).replace('Lot_V', ''), 10);
                const bIndex = parseInt(String(b.name).replace('Lot_V', ''), 10);
                const safeA = Number.isFinite(aIndex) ? aIndex : Number.MAX_SAFE_INTEGER;
                const safeB = Number.isFinite(bIndex) ? bIndex : Number.MAX_SAFE_INTEGER;
                if (safeA !== safeB) return safeA - safeB;
                return String(a.name).localeCompare(String(b.name));
            });
    }

    function getSerializedBorderLineConnections() {
        dedupeBorderConnections(borderLineConnections, borderDots);
        return borderLineConnections
            .filter((connection) => borderDots[connection.start] && borderDots[connection.end] && connection.start !== connection.end)
            .map((connection) => ({ start: connection.start, end: connection.end }));
    }

    function getSerializedTapDotPositions() {
        return getActiveTapDots().map((tapDot) => {
            const pos = tapDot.dot.position;
            const cfg = tapDot.config;
            const item = {
                position: {
                    x: +pos.x.toFixed(6),
                    y: +pos.y.toFixed(6),
                    z: +pos.z.toFixed(6)
                },
                scale: cfg.scale ?? 1,
                icon: cfg.icon || 'info'
            };
            if (cfg.caption) item.caption = cfg.caption;
            if (cfg.photos && cfg.photos.length) item.photos = cfg.photos;
            else if (cfg.photo) item.photo = cfg.photo;
            return item;
        });
    }

    function buildLotGeometryPayload() {
        return {
            borderDotPositions: getSerializedBorderDotPositions(),
            borderLineConnections: getSerializedBorderLineConnections(),
            tapDotPositions: getSerializedTapDotPositions(),
            metadata: {
                northDirection: parameters.compass.northDirection
            }
        };
    }

    async function copyTextToClipboard(text) {
        if (navigator.clipboard && window.isSecureContext) {
            await navigator.clipboard.writeText(text);
            return true;
        }

        const tempTextarea = document.createElement('textarea');
        tempTextarea.value = text;
        tempTextarea.setAttribute('readonly', '');
        tempTextarea.style.position = 'fixed';
        tempTextarea.style.opacity = '0';
        tempTextarea.style.pointerEvents = 'none';
        document.body.appendChild(tempTextarea);
        tempTextarea.focus();
        tempTextarea.select();

        let copied = false;
        try {
            copied = document.execCommand('copy');
        } catch (error) {
            copied = false;
        }
        document.body.removeChild(tempTextarea);
        return copied;
    }

    function insertVertexAtConnection(startName, endName) {
        const connectionIndex = getConnectionIndex(borderLineConnections, borderDots, startName, endName);
        if (connectionIndex < 0) return;
        const connection = borderLineConnections[connectionIndex];
        const startDot = borderDots[connection.start];
        const endDot = borderDots[connection.end];
        if (!startDot || !endDot) return;

        const midpoint = new Vector3().addVectors(startDot.position, endDot.position).multiplyScalar(0.5);
        const newVertexName = getNextBorderVertexName();
        const createdDot = createBorderDot({
            name: newVertexName,
            position: { x: midpoint.x, y: midpoint.y, z: midpoint.z }
        });
        borderDots[newVertexName] = createdDot.mesh;

        borderLineConnections.splice(
            connectionIndex,
            1,
            { start: connection.start, end: newVertexName },
            { start: newVertexName, end: connection.end }
        );

        rebuildBorderLines();
        selectBorderVertex(newVertexName);
        setLotEditorStatus(`Inserted ${newVertexName}. Drag to refine this segment.`);
        updateMidpointButtons();
    }

    function getMergeTargetForDraggedVertex(draggedVertexName) {
        const draggedDot = borderDots[draggedVertexName];
        if (!draggedDot) return null;
        const draggedScreen = getScreenPositionFromWorld(draggedDot.position);
        if (!draggedScreen.visible) return null;

        let closestName = null;
        let closestDistance = Infinity;
        Object.entries(borderDots).forEach(([candidateName, candidateDot]) => {
            if (candidateName === draggedVertexName) return;
            const candidateScreen = getScreenPositionFromWorld(candidateDot.position);
            if (!candidateScreen.visible) return;
            const distance = Math.hypot(candidateScreen.x - draggedScreen.x, candidateScreen.y - draggedScreen.y);
            if (distance < lotEditState.mergeScreenDistancePx && distance < closestDistance) {
                closestDistance = distance;
                closestName = candidateName;
            }
        });
        return closestName;
    }

    function mergeVertices(sourceVertexName, targetVertexName) {
        if (!sourceVertexName || !targetVertexName || sourceVertexName === targetVertexName) return false;
        if (!borderDots[sourceVertexName] || !borderDots[targetVertexName]) return false;

        const mapped = borderLineConnections.map((connection) => ({
            start: connection.start === sourceVertexName ? targetVertexName : connection.start,
            end: connection.end === sourceVertexName ? targetVertexName : connection.end
        }));
        borderLineConnectionsByHole[activeHoleIndex] = mapped;
        borderLineConnections = mapped;
        dedupeBorderConnections(borderLineConnections, borderDots);

        const sourceDot = borderDots[sourceVertexName];
        scene.remove(sourceDot);
        sourceDot.geometry.dispose();
        sourceDot.material.dispose();
        delete borderDots[sourceVertexName];

        rebuildBorderLines();
        selectBorderVertex(targetVertexName);
        setLotEditorStatus(`Merged ${sourceVertexName} into ${targetVertexName}.`);
        updateMidpointButtons();
        return true;
    }

    function startTapDotDragFromPotential() {
        if (!lotEditState.potentialTapDotDrag) return;
        const tapDot = lotEditState.potentialTapDotDrag;
        lotEditState.draggingTapDot = tapDot;
        lotEditState.draggingTapDotPointerId = lotEditState.potentialTapDotDragPointerId;
        lotEditState.draggingTapDotPlaneY = tapDot.dot.position.y;
        lotEditState.potentialTapDotDrag = null;
        lotEditState.potentialTapDotDragPointerId = null;
        controls.enabled = false;
        setLotEditorStatus(`Dragging tap dot. Release to place.`);
    }

    function endTapDotDrag() {
        if (!lotEditState.draggingTapDot) return;
        const wasDragging = lotEditState.draggingTapDot;
        lotEditState.draggingTapDot = null;
        lotEditState.draggingTapDotPointerId = null;
        controls.enabled = true;
        selectTapDot(wasDragging);
        if (lotEditState.active) {
            setLotEditorStatus(`Selected tap dot: ${wasDragging.config.caption || wasDragging.config.icon || 'Tap dot'}. Edit XYZ in panel.`);
        }
    }

    function clearPotentialTapDotDrag() {
        if (lotEditState.potentialTapDotDrag) {
            lotEditState.potentialTapDotDrag = null;
            lotEditState.potentialTapDotDragPointerId = null;
        }
    }

    function endLotVertexDrag(clearOnly = false) {
        if (clearOnly) clearPotentialTapDotDrag();
        if (lotEditState.draggingTapDot) {
            endTapDotDrag();
            return;
        }
        if (!lotEditState.dragging.active && !clearOnly) return;
        lotEditState.dragging.active = false;
        lotEditState.dragging.pointerId = null;
        lotEditState.dragging.vertexName = null;
        lotEditState.dragging.mergeTargetName = null;
        lotEditState.dragging.mergeHoverStartMs = 0;
        if (lotEditState.dragging.mergeTimerId) {
            clearTimeout(lotEditState.dragging.mergeTimerId);
            lotEditState.dragging.mergeTimerId = null;
        }
        controls.enabled = true;
        refreshBorderVisualState();
        if (lotEditState.active) {
            const selectedName = lotEditState.selectedVertexName;
            if (selectedName && borderDots[selectedName]) {
                setLotEditorStatus(`Selected ${selectedName} (${getConnectionCountForVertex(selectedName)} connections).`);
            } else {
                setLotEditorStatus('Drag vertices or tap dots to reposition. Use + to insert points, hold for 1.5s to merge.');
            }
        }
    }

    function showTapDotContent(tapDot) {
        if (!tapDot) return;
        const cfg = tapDot.config;
        if (cfg.icon === 'info') {
            return;
        } else {
            const popup = document.getElementById('tapdotPopup');
            const photoEl = document.getElementById('tapdotPopupPhoto');
            const captionEl = document.getElementById('tapdotPopupCaption');
            const photos = (cfg.photos || (cfg.photo ? [cfg.photo] : [])).map(resolveTapDotPhotoUrl);
            if (popup && photoEl && captionEl) {
                photoEl.alt = cfg.caption || '';
                captionEl.textContent = cfg.caption || '';
                window.tapdotCarouselPhotos = photos;
                window.tapdotCarouselIndex = 0;
                const carouselNav = document.getElementById('tapdotCarouselNav');
                const dotsContainer = document.getElementById('tapdotCarouselDots');
                if (photos.length > 1) {
                    carouselNav.classList.remove('hidden');
                    carouselNav.classList.add('visible');
                    dotsContainer.innerHTML = '';
                    for (let i = 0; i < photos.length; i++) {
                        const dot = document.createElement('div');
                        dot.className = 'tapdot-carousel-dot' + (i === 0 ? ' active' : '');
                        dot.setAttribute('data-index', i);
                        dotsContainer.appendChild(dot);
                    }
                } else {
                    carouselNav.classList.add('hidden');
                    carouselNav.classList.remove('visible');
                    dotsContainer.innerHTML = '';
                }
                const firstSrc = photos[0] || '';
                const spinnerEl = document.getElementById('tapdotPhotoSpinner');
                popup.style.width = '';
                popup.style.height = '';
                document.getElementById('overlay-ui').classList.add('active');
                window.isTapdotPopupOpen = true;
                const showPopup = () => {
                    popup.classList.add('show');
                };
                if (firstSrc) {
                    popup.style.width = 'min(90vw, 800px)';
                    popup.style.height = 'min(85vh, 600px)';
                    requestAnimationFrame(() => requestAnimationFrame(showPopup));
                    if (spinnerEl) spinnerEl.classList.add('visible');
                    photoEl.src = '';
                    const img = new Image();
                    const hideSpinner = () => {
                        if (spinnerEl) spinnerEl.classList.remove('visible');
                    };
                    img.onload = () => {
                        hideSpinner();
                        const maxW = window.innerWidth - 48;
                        const maxH = window.innerHeight - 80;
                        let w = img.naturalWidth;
                        let h = img.naturalHeight;
                        if (w > maxW || h > maxH) {
                            const r = Math.min(maxW / w, maxH / h);
                            w = Math.round(w * r);
                            h = Math.round(h * r);
                        }
                        popup.style.width = w + 'px';
                        popup.style.height = h + 'px';
                        photoEl.src = firstSrc;
                    };
                    img.onerror = hideSpinner;
                    img.src = firstSrc;
                    if (img.complete) img.onload();
                } else {
                    if (spinnerEl) spinnerEl.classList.remove('visible');
                    photoEl.src = '';
                    popup.style.width = 'min(90vw, 800px)';
                    popup.style.height = 'min(85vh, 600px)';
                    requestAnimationFrame(() => requestAnimationFrame(showPopup));
                }
            }
        }
    }

    function beginTapDotDrag(event) {
        if (!lotEditState.active) return false;
        if (event.button !== undefined && event.button !== 0) return false;
        const hitTapDot = getTapDotHit(event);
        if (!hitTapDot) return false;

        const now = performance.now();
        if (now - lotEditState.lastTapDotPointerDownTime < 400 && lotEditState.lastTapDotPointerDownTarget === hitTapDot) {
            lotEditState.lastTapDotPointerDownTime = 0;
            lotEditState.lastTapDotPointerDownTarget = null;
            return false;
        }
        lotEditState.lastTapDotPointerDownTime = now;
        lotEditState.lastTapDotPointerDownTarget = hitTapDot;

        lotEditState.potentialTapDotDrag = hitTapDot;
        lotEditState.potentialTapDotDragPointerId = event.pointerId;
        lotEditState.suppressNextClick = true;
        setLotEditorStatus(`Tap to select, drag to move.`);
        if (renderer.domElement.setPointerCapture) {
            renderer.domElement.setPointerCapture(event.pointerId);
        }
        return true;
    }

    function beginLotVertexDrag(event) {
        if (!lotEditState.active) return false;
        if (event.button !== undefined && event.button !== 0) return false;
        const hitVertex = getBorderVertexHit(event);
        if (!hitVertex || !hitVertex.userData.borderVertexName) return false;

        const vertexName = hitVertex.userData.borderVertexName;
        selectBorderVertex(vertexName);
        lotEditState.dragging.active = true;
        lotEditState.dragging.pointerId = event.pointerId;
        lotEditState.dragging.vertexName = vertexName;
        lotEditState.dragging.planeY = hitVertex.position.y;
        lotEditState.dragging.mergeTargetName = null;
        lotEditState.dragging.mergeHoverStartMs = 0;
        lotEditState.dragging.mergeTimerId = null;
        lotEditState.suppressNextClick = true;
        controls.enabled = false;
        setLotEditorStatus(`Dragging ${vertexName}. Hold over another vertex for 1.5s to merge.`);
        refreshBorderVisualState();
        if (renderer.domElement.setPointerCapture) {
            renderer.domElement.setPointerCapture(event.pointerId);
        }
        return true;
    }

    function updateTapDotDrag(event) {
        if (!lotEditState.draggingTapDot) return;
        if (event.pointerId !== lotEditState.draggingTapDotPointerId) return;

        const tapDot = lotEditState.draggingTapDot;
        const pointOnPlane = getPointerWorldOnPlane(event, lotEditState.draggingTapDotPlaneY);
        if (!pointOnPlane) return;
        tapDot.dot.position.x = pointOnPlane.x;
        tapDot.dot.position.y = lotEditState.draggingTapDotPlaneY;
        tapDot.dot.position.z = pointOnPlane.z;
        if (tapDot.config.position) {
            tapDot.config.position.x = pointOnPlane.x;
            tapDot.config.position.y = lotEditState.draggingTapDotPlaneY;
            tapDot.config.position.z = pointOnPlane.z;
        }
    }

    function updateLotVertexDrag(event) {
        if (lotEditState.draggingTapDot) {
            updateTapDotDrag(event);
            return;
        }
        if (!lotEditState.dragging.active) return;
        if (event.pointerId !== lotEditState.dragging.pointerId) return;

        const vertexName = lotEditState.dragging.vertexName;
        const vertexDot = borderDots[vertexName];
        if (!vertexDot) {
            endLotVertexDrag(true);
            return;
        }

        const pointOnPlane = getPointerWorldOnPlane(event, lotEditState.dragging.planeY);
        if (!pointOnPlane) return;
        vertexDot.position.x = pointOnPlane.x;
        vertexDot.position.y = lotEditState.dragging.planeY;
        vertexDot.position.z = pointOnPlane.z;
        rebuildBorderLines();
        syncLotEditorInputsFromSelection();
        updateMidpointButtons();

        const mergeTargetName = getMergeTargetForDraggedVertex(vertexName);
        if (mergeTargetName !== lotEditState.dragging.mergeTargetName) {
            if (lotEditState.dragging.mergeTimerId) {
                clearTimeout(lotEditState.dragging.mergeTimerId);
                lotEditState.dragging.mergeTimerId = null;
            }
            lotEditState.dragging.mergeTargetName = mergeTargetName;
            lotEditState.dragging.mergeHoverStartMs = mergeTargetName ? performance.now() : 0;
            if (mergeTargetName) {
                setLotEditorStatus(`Hold to merge ${vertexName} into ${mergeTargetName}...`);
                const sourceVertex = vertexName;
                const targetVertex = mergeTargetName;
                lotEditState.dragging.mergeTimerId = setTimeout(() => {
                    if (!lotEditState.dragging.active) return;
                    if (lotEditState.dragging.vertexName !== sourceVertex) return;
                    if (lotEditState.dragging.mergeTargetName !== targetVertex) return;
                    const merged = mergeVertices(sourceVertex, targetVertex);
                    endLotVertexDrag(true);
                    if (merged) {
                        setLotEditorStatus(`Merged ${sourceVertex} into ${targetVertex}.`);
                    }
                }, lotEditState.mergeHoldMs);
            } else {
                setLotEditorStatus(`Dragging ${vertexName}. Hold over another vertex for 1.5s to merge.`);
            }
            refreshBorderVisualState();
            return;
        }
    }

    function setLotEditMode(enabled) {
        if (enabled === lotEditState.active) return;

        lotEditState.active = enabled;
        lotEditorToggle.classList.toggle('active', enabled);
        lotEditorToggle.setAttribute('aria-pressed', enabled ? 'true' : 'false');
        lotEditorPanel.classList.toggle('active', enabled);

        if (enabled) {
            lotEditState.cameraSnapshot = {
                position: camera.position.clone(),
                target: controls.target.clone(),
                up: camera.up.clone(),
                controlsEnabled: controls.enabled,
                controlsRotateEnabled: controls.enableRotate,
                autoRotate,
                pathEnabled: pathAnimationState.enabled,
                pathPlaying: pathAnimationState.playing,
                pathLoop: pathAnimationState.loop,
                pathSpeed: pathAnimationState.speed,
                pathSegmentIndex: pathAnimationState.segmentIndex,
                pathSegmentElapsed: pathAnimationState.segmentElapsed
            };
            autoRotate = false;
            isAnimatingToNorth = false;
            pathAnimationState.playing = false;
            if (lotEditState.selectedTapDot) {
                syncLotEditorInputsFromSelection();
            } else if (!lotEditState.selectedVertexName || !borderDots[lotEditState.selectedVertexName]) {
                selectBorderVertex(Object.keys(borderDots)[0] || null);
            } else {
                syncLotEditorInputsFromSelection();
            }
            setLotEditorStatus('Drag vertices or tap dots to reposition. Use + to insert points, hold for 1.5s to merge.');
            refreshBorderVisualState();
            updateMidpointButtons();
            return;
        }

        clearMidpointButtons();
        endLotVertexDrag(true);
        const snapshot = lotEditState.cameraSnapshot;
        if (snapshot) {
            camera.position.copy(snapshot.position);
            controls.target.copy(snapshot.target);
            camera.up.copy(snapshot.up);
            controls.enabled = snapshot.controlsEnabled;
            controls.enableRotate = snapshot.controlsRotateEnabled;
            autoRotate = snapshot.autoRotate;
            pathAnimationState.enabled = snapshot.pathEnabled ?? pathAnimationState.enabled;
            pathAnimationState.playing = snapshot.pathPlaying ?? false;
            pathAnimationState.loop = snapshot.pathLoop ?? pathAnimationState.loop;
            pathAnimationState.speed = Number.isFinite(snapshot.pathSpeed) ? snapshot.pathSpeed : pathAnimationState.speed;
            pathAnimationState.segmentIndex = Number.isFinite(snapshot.pathSegmentIndex) ? snapshot.pathSegmentIndex : 0;
            pathAnimationState.segmentElapsed = Number.isFinite(snapshot.pathSegmentElapsed) ? snapshot.pathSegmentElapsed : 0;
            controls.update();
        } else {
            controls.enableRotate = true;
            controls.enabled = true;
        }
        setLotEditorStatus('Enable mode, then drag vertices or tap dots to adjust positions.');
        refreshBorderVisualState();
        syncAnimationEditorFromState();
    }

    function updateSelectedCoordinate(axis, value) {
        if (!Number.isFinite(value)) return;
        const selectedTapDot = lotEditState.selectedTapDot;
        if (selectedTapDot) {
            selectedTapDot.dot.position[axis] = value;
            if (selectedTapDot.config.position) {
                selectedTapDot.config.position[axis] = value;
            }
            if (axis === 'y') {
                lotEditState.draggingTapDotPlaneY = value;
            }
            syncLotEditorInputsFromSelection();
            setLotEditorStatus(`Updated tap dot ${selectedTapDot.config.caption || ''}.`);
            return;
        }
        const selectedName = lotEditState.selectedVertexName;
        if (!selectedName || !borderDots[selectedName]) return;
        borderDots[selectedName].position[axis] = value;
        if (axis === 'y') {
            lotEditState.dragging.planeY = value;
        }
        rebuildBorderLines();
        syncLotEditorInputsFromSelection();
        setLotEditorStatus(`Updated ${selectedName} (${getConnectionCountForVertex(selectedName)} connections).`);
        updateMidpointButtons();
    }

    renderer.domElement.addEventListener('pointerdown', (event) => {
        if (!lotEditState.active) return;
        let started = beginLotVertexDrag(event);
        if (!started) started = beginTapDotDrag(event);
        if (started) {
            event.preventDefault();
            event.stopPropagation();
        }
    }, { passive: false, capture: true });

    renderer.domElement.addEventListener('dblclick', (event) => {
        if (!lotEditState.active) return;
        const hitTapDot = getTapDotHit(event);
        if (hitTapDot) {
            showTapDotContent(hitTapDot);
            event.preventDefault();
            event.stopPropagation();
        }
    }, { passive: false, capture: true });

    window.addEventListener('pointermove', (event) => {
        if (lotEditState.potentialTapDotDrag && event.pointerId === lotEditState.potentialTapDotDragPointerId) {
            startTapDotDragFromPotential();
        }
        if (!lotEditState.dragging.active && !lotEditState.draggingTapDot) return;
        updateLotVertexDrag(event);
        event.preventDefault();
    }, { passive: false });

    window.addEventListener('pointerup', (event) => {
        if (lotEditState.potentialTapDotDrag && event.pointerId === lotEditState.potentialTapDotDragPointerId) {
            selectTapDot(lotEditState.potentialTapDotDrag);
            clearPotentialTapDotDrag();
            event.preventDefault();
            return;
        }
        if (lotEditState.draggingTapDot) {
            if (event.pointerId === lotEditState.draggingTapDotPointerId) endLotVertexDrag();
            return;
        }
        if (!lotEditState.dragging.active) return;
        if (event.pointerId !== lotEditState.dragging.pointerId) return;
        endLotVertexDrag();
        event.preventDefault();
    }, { passive: false });

    window.addEventListener('pointercancel', () => {
        clearPotentialTapDotDrag();
        endLotVertexDrag(true);
    }, { passive: true });

    if (lotEditorToggle) {
        lotEditorToggle.addEventListener('click', () => {
            setLotEditMode(!lotEditState.active);
        });
    }

    lotVertexXInput.addEventListener('input', () => updateSelectedCoordinate('x', parseFloat(lotVertexXInput.value)));
    lotVertexYInput.addEventListener('input', () => updateSelectedCoordinate('y', parseFloat(lotVertexYInput.value)));
    lotVertexZInput.addEventListener('input', () => updateSelectedCoordinate('z', parseFloat(lotVertexZInput.value)));
    lotCopyJsonButton.addEventListener('click', async () => {
        const payload = buildLotGeometryPayload();
        const jsonText = JSON.stringify(payload, null, 2);
        lotEditState.lastExportJson = jsonText;
        window.__lotExportJson = jsonText;
        window.__lotExportPayload = payload;
        try {
            const copied = await copyTextToClipboard(jsonText);
            if (copied) {
                const parts = [`${payload.borderDotPositions.length} vertices`, `${payload.borderLineConnections.length} connections`];
                if (payload.tapDotPositions && payload.tapDotPositions.length) {
                    parts.push(`${payload.tapDotPositions.length} tap dots`);
                }
                setLotEditorStatus(`Copied ${parts.join(', ')}.`);
                return;
            }
        } catch (error) {
            // Fall through to prompt fallback.
        }

        try {
            window.prompt('Copy your lot JSON', jsonText);
            setLotEditorStatus(`JSON ready (${payload.borderDotPositions.length} vertices, ${payload.borderLineConnections.length} connections).`);
        } catch (error) {
            setLotEditorStatus('Unable to copy automatically. Clipboard blocked.');
        }
    });

    if (splatEditorToggle) {
        splatEditorToggle.addEventListener('click', () => setSplatEditorOpen(!splatEditorState.open));
    }
    if (splatEditorCloseButton) {
        splatEditorCloseButton.addEventListener('click', () => setSplatEditorOpen(false));
    }
    [splatPosX, splatPosY, splatPosZ, splatRotX, splatRotY, splatRotZ, splatScale].forEach((input) => {
        if (!input) return;
        input.addEventListener('input', () => applySplatEditorToConfig());
        input.addEventListener('change', () => applySplatEditorToConfig());
    });
    if (splatExportButton) {
        splatExportButton.addEventListener('click', async () => {
            const payload = getSplatExportPayload();
            if (!payload) return;
            const jsonText = JSON.stringify(payload, null, 2);
            const snippet = `splat: ${jsonText}`;
            window.__splatExport = snippet;
            try {
                const copied = await copyTextToClipboard(snippet);
                if (copied) {
                    if (splatEditorStatus) splatEditorStatus.textContent = 'Copied splat config.';
                    return;
                }
            } catch (error) {}
            try {
                window.prompt('Copy splat config', snippet);
                if (splatEditorStatus) splatEditorStatus.textContent = 'Splat JSON ready.';
            } catch (error) {
                if (splatEditorStatus) splatEditorStatus.textContent = 'Unable to copy.';
            }
        });
    }

    if (animationEditorToggle) {
        animationEditorToggle.addEventListener('click', () => {
            setAnimationEditorOpen(!animationEditorState.open);
        });
    }
    if (animationEditorCloseButton) {
        animationEditorCloseButton.addEventListener('click', () => {
            setAnimationEditorOpen(false);
        });
    }
    window.addEventListener('keydown', (event) => {
        if (event.key !== 'Escape') return;
        if (splatEditorState.open) {
            setSplatEditorOpen(false);
            return;
        }
        if (!animationEditorState.open) return;
        setAnimationEditorOpen(false);
    });
    if (animationCaptureCheckpointButton) {
        animationCaptureCheckpointButton.addEventListener('click', captureCheckpointFromCurrentView);
    }
    if (animationPlayToggleButton) {
        animationPlayToggleButton.addEventListener('click', togglePathPlayback);
    }
    if (animationExportButton) {
        animationExportButton.addEventListener('click', exportCameraPathToClipboard);
    }

    syncLotEditorInputsFromSelection();
    initializeAnimationEditor();
    initializeSplatEditor();

    // Original base spacing and sizes:
    const baseMenuLeft = 20;
    const baseMenuBottom = 20;
    const baseDetailsTop = 60;
    const baseDetailsBottom = 60;
    const baseDetailsLeft = 20;
    const baseDetailsRight = 20;

    // Original font sizes:
    const baseH1 = 30;
    const baseP = 17;
    const baseDisclaimer = 10;

    // Original details-inner padding:
    const basePaddingTopBottom = 40;
    const basePaddingLeftRight = 30;

    // Original menu-container dimensions, padding, and gap (for scaling):
    const baseMenuWidth = 105;
    const baseMenuHeight = 59;
    const baseMenuPadding = 7;
    const baseMenuGap = 1;
    const baseMenuBorderRadius = 30;
    const baseButtonWidth = 45;
    const baseButtonHeight = 45;

    function applyLayoutMode() {
        const ratio = window.innerWidth / window.innerHeight;
        let mode;
        if (ratio > 4/3) {
            mode = 'desktop';
        } else if (ratio >= 3/4 && ratio <= 4/3) {
            mode = 'tablet';
        } else {
            mode = 'mobile';
        }

        let menuLeft = baseMenuLeft;
        let menuBottom = baseMenuBottom;
        let detailsTop = baseDetailsTop;
        let detailsBottom = baseDetailsBottom;
        let detailsLeft = baseDetailsLeft;
        let detailsRight = baseDetailsRight;
        let scaleFactor = 1.0;
        let h1Size = baseH1;
        let pSize = baseP;
        let disclaimerSize = baseDisclaimer;
        let innerPaddingTopBottom = basePaddingTopBottom;
        let innerPaddingLeftRight = basePaddingLeftRight;

        if (mode === 'desktop') {
            menuLeft += 20; 
            menuBottom += 20;
            detailsLeft += 20;
            detailsRight += 20;
            detailsTop += 20;
            detailsBottom += 20;
        } else if (mode === 'tablet') {
            scaleFactor = 0.9;
            h1Size = Math.round(baseH1 * 0.9);
            pSize = Math.round(baseP * 0.9);
            disclaimerSize = Math.round(baseDisclaimer * 0.9);
        } else {
            // Mobile
            menuLeft = baseMenuLeft - 5;
            menuBottom = baseMenuBottom - 5;
            detailsLeft = baseDetailsLeft - 5;
            detailsRight = baseDetailsRight - 5;
            detailsTop = baseDetailsTop - 5;
            detailsBottom = baseDetailsBottom - 10;
            scaleFactor = 0.8;
            h1Size = Math.round(baseH1 * 0.8);
            pSize = Math.round(baseP * 0.8);
            disclaimerSize = Math.round(baseDisclaimer * 0.8);
            innerPaddingTopBottom = basePaddingTopBottom - 7;
            innerPaddingLeftRight = basePaddingLeftRight - 15;
        }

        menuContainer.style.bottom = menuBottom + 'px';
        menuContainer.style.left = menuLeft + 'px';

        menuContainer.style.webkitTransform = 'scale(' + scaleFactor + ')';
        menuContainer.style.transform = 'scale(' + scaleFactor + ')';

        detailsBox.style.top = detailsTop + 'px';
        detailsBox.style.bottom = detailsBottom + 'px';
        detailsBox.style.left = detailsLeft + 'px';
        detailsBox.style.right = detailsRight + 'px';
        detailsBox.style.maxHeight = '';

        const h1s = detailsBox.querySelectorAll('h1');
        h1s.forEach(h => { h.style.fontSize = h1Size + 'px'; });

        const ps = detailsBox.querySelectorAll('p');
        ps.forEach(pElem => { pElem.style.fontSize = pSize + 'px'; });

        const disclaimers = detailsBox.querySelectorAll('.legal-disclaimer');
        disclaimers.forEach(d => { d.style.fontSize = disclaimerSize + 'px'; });

        detailsInner.style.padding = innerPaddingTopBottom + 'px ' + innerPaddingLeftRight + 'px';
    }

    function animateIconChange(imgElement, newSrc) {
        imgElement.style.animation = 'none';
        imgElement.offsetHeight;
        imgElement.style.webkitAnimation = 'shrinkIcon 0.1s ease forwards';
        imgElement.style.animation = 'shrinkIcon 0.1s ease forwards';

        function handleShrink(e) {
            if (e.animationName === 'shrinkIcon') {
                if (newSrc) imgElement.src = newSrc;
                imgElement.style.animation = 'none';
                imgElement.style.webkitAnimation = 'none';
                imgElement.offsetHeight; 
                imgElement.style.webkitAnimation = 'expandIcon 0.3s cubic-bezier(0.34, 1.56, 0.64, 1) forwards';
                imgElement.style.animation = 'expandIcon 0.3s cubic-bezier(0.34, 1.56, 0.64, 1) forwards';
            } else if (e.animationName === 'expandIcon') {
                imgElement.removeEventListener('animationend', handleShrink);
                imgElement.removeEventListener('webkitAnimationEnd', handleShrink);
            }
        }

        imgElement.addEventListener('animationend', handleShrink);
        imgElement.addEventListener('webkitAnimationEnd', handleShrink);
    }

    function openDetails() {
        isDetailsOpen = true;
        detailsBox.classList.add('show');
        animateIconChange(detailsButton.querySelector('img'), 'https://raw.githubusercontent.com/HansenHomeAI/FigmaSVGButtons/main/Close2IconDefault.svg');
        overlayUI.classList.add('active');
        updateScrollbar();
    }

    function closeDetails() {
        isDetailsOpen = false;
        detailsBox.classList.remove('show');
        animateIconChange(detailsButton.querySelector('img'), 'https://raw.githubusercontent.com/HansenHomeAI/FigmaSVGButtons/main/DetailsIconDefault.svg');
        overlayUI.classList.remove('active');
    }

    detailsButton.addEventListener('click', () => {
        const img = detailsButton.querySelector('img');
        if (isDetailsOpen) {
            animateIconChange(img, 'https://raw.githubusercontent.com/HansenHomeAI/FigmaSVGButtons/main/DetailsIconDefault.svg');
            closeDetails();
        } else {
            animateIconChange(img, 'https://raw.githubusercontent.com/HansenHomeAI/FigmaSVGButtons/main/Close2IconDefault.svg');
            openDetails();
        }
    });

    // Add click listener for compass button (dual purpose: north face OR animation start)
    compassButton.addEventListener('click', (event) => {
        const mode = (parameters.compass.northButtonMode || 'north').toLowerCase();
        if (mode === 'animationstart') {
            goToAnimationStart();
        } else {
            animateCameraToNorth();
        }
    });
    // Set compass button tooltip based on mode
    if (compassButton) {
        const mode = (parameters.compass.northButtonMode || 'north').toLowerCase();
        compassButton.title = mode === 'animationstart' ? 'Go to animation start' : 'Face north';
    }

    fullscreenButton.addEventListener('click', async () => {
        const img = fullscreenButton.querySelector('img');
        let newSrc;
        if (document.fullscreenElement) {
            await document.exitFullscreen().catch(() => {});
            newSrc = 'https://raw.githubusercontent.com/HansenHomeAI/FigmaSVGButtons/main/FullScreenIconDefault.svg';
        } else {
            try {
                await document.documentElement.requestFullscreen();
                newSrc = 'https://raw.githubusercontent.com/HansenHomeAI/FigmaSVGButtons/main/MinimizeIconDefault.svg';
            } catch (err) {
                console.error(`Error: ${err.message} (${err.name})`);
                newSrc = 'https://raw.githubusercontent.com/HansenHomeAI/FigmaSVGButtons/main/FullScreenIconDefault.svg';
            }
        }
        animateIconChange(img, newSrc);
    });

    function updateFullscreenIcon() {
        const img = fullscreenButton.querySelector('img');
        if (document.fullscreenElement) {
            animateIconChange(img, 'https://raw.githubusercontent.com/HansenHomeAI/FigmaSVGButtons/main/MinimizeIconDefault.svg');
        } else {
            animateIconChange(img, 'https://raw.githubusercontent.com/HansenHomeAI/FigmaSVGButtons/main/FullScreenIconDefault.svg');
        }
    }

    document.addEventListener('fullscreenchange', updateFullscreenIcon);

    window.isTapdotPopupOpen = false;
    window.tapdotCarouselPhotos = [];
    window.tapdotCarouselIndex = 0;
    const tapdotPopup = document.getElementById('tapdotPopup');
    const tapdotPopupClose = document.getElementById('tapdotPopupClose');

    function closeTapdotPopup() {
        if (!tapdotPopup) return;
        window.isTapdotPopupOpen = false;
        tapdotPopup.classList.remove('show');
        if (!isDetailsOpen) overlayUI.classList.remove('active');
        const spinner = document.getElementById('tapdotPhotoSpinner');
        if (spinner) spinner.classList.remove('visible');
        setTimeout(() => {
            tapdotPopup.style.width = '';
            tapdotPopup.style.height = '';
        }, 320);
    }

    function tapdotCarouselGoTo(idx) {
        const photos = window.tapdotCarouselPhotos;
        if (!photos || photos.length < 2 || idx < 0 || idx >= photos.length) return;
        window.tapdotCarouselIndex = idx;
        const photoEl = document.getElementById('tapdotPopupPhoto');
        const spinnerEl = document.getElementById('tapdotPhotoSpinner');
        const dots = document.querySelectorAll('.tapdot-carousel-dot');
        dots.forEach((d, i) => d.classList.toggle('active', i === idx));
        if (photoEl) {
            photoEl.classList.add('fade');
            const newSrc = photos[idx];
            if (spinnerEl) spinnerEl.classList.add('visible');
            const img = new Image();
            const hideSpinner = () => {
                if (spinnerEl) spinnerEl.classList.remove('visible');
            };
            img.onload = () => {
                hideSpinner();
                photoEl.src = newSrc;
                requestAnimationFrame(() => { photoEl.classList.remove('fade'); });
            };
            img.onerror = hideSpinner;
            img.src = newSrc;
            if (img.complete) img.onload();
        }
    }

    function tapdotCarouselNav(direction) {
        const photos = window.tapdotCarouselPhotos;
        if (!photos || photos.length < 2) return;
        let idx = (window.tapdotCarouselIndex + direction + photos.length) % photos.length;
        tapdotCarouselGoTo(idx);
    }

    if (tapdotPopupClose) {
        tapdotPopupClose.addEventListener('click', () => closeTapdotPopup());
    }
    const tapdotCarouselPrev = document.getElementById('tapdotCarouselPrev');
    const tapdotCarouselNext = document.getElementById('tapdotCarouselNext');
    const tapdotCarouselDots = document.getElementById('tapdotCarouselDots');
    const tapdotPopupPhoto = document.getElementById('tapdotPopupPhoto');
    if (tapdotCarouselPrev) tapdotCarouselPrev.addEventListener('click', (e) => { e.stopPropagation(); tapdotCarouselNav(-1); });
    if (tapdotCarouselNext) tapdotCarouselNext.addEventListener('click', (e) => { e.stopPropagation(); tapdotCarouselNav(1); });
    if (tapdotPopupPhoto) tapdotPopupPhoto.addEventListener('click', (e) => { e.stopPropagation(); tapdotCarouselNav(1); });
    if (tapdotCarouselDots) {
        tapdotCarouselDots.addEventListener('click', (e) => {
            const dot = e.target.closest('.tapdot-carousel-dot');
            if (dot) { e.stopPropagation(); tapdotCarouselGoTo(parseInt(dot.getAttribute('data-index'), 10)); }
        });
    }

    let tapdotSwipeStartX = 0;
    const tapdotSwipeThreshold = 50;
    tapdotPopup.addEventListener('touchstart', (e) => {
        if (e.touches.length === 1 && window.tapdotCarouselPhotos && window.tapdotCarouselPhotos.length > 1) {
            tapdotSwipeStartX = e.touches[0].clientX;
        }
    }, { passive: true });
    tapdotPopup.addEventListener('touchend', (e) => {
        if (e.changedTouches.length === 1 && window.tapdotCarouselPhotos && window.tapdotCarouselPhotos.length > 1) {
            const delta = e.changedTouches[0].clientX - tapdotSwipeStartX;
            if (delta < -tapdotSwipeThreshold) tapdotCarouselNav(1);
            else if (delta > tapdotSwipeThreshold) tapdotCarouselNav(-1);
        }
    }, { passive: true });

    overlayUI.addEventListener('click', () => {
        if (isDetailsOpen) {
            closeDetails();
        }
        if (window.isTapdotPopupOpen) {
            closeTapdotPopup();
        }
    });

    function updateScrollbar() {
        const contentHeight = detailsContent.scrollHeight;
        const visibleHeight = detailsContent.clientHeight;
        const detailsBoxRect = detailsBox.getBoundingClientRect();
        
        const topMargin = 30;
        const bottomMargin = 30;
        const trackHeight = detailsBoxRect.height - (topMargin + bottomMargin); 
        const thumbHeight = Math.max((visibleHeight / contentHeight) * trackHeight, 20);
        customThumb.style.height = thumbHeight + 'px';

        const scrollRatio = (detailsContent.scrollTop / (contentHeight - visibleHeight)) || 0;
        const thumbMaxY = trackHeight - thumbHeight;
        const thumbY = topMargin + thumbMaxY * scrollRatio;
        customThumb.style.top = thumbY + 'px';
    }

    detailsContent.addEventListener('scroll', () => {
        updateScrollbar();
        showScrollbar();
    });

    customThumb.addEventListener('mousedown', (e) => {
        isDraggingThumb = true;
        dragStartY = e.clientY;
        startScrollTop = detailsContent.scrollTop;
        document.addEventListener('mousemove', onThumbDrag);
        document.addEventListener('mouseup', onThumbRelease);
        e.preventDefault();
    });

    function onThumbDrag(e) {
        if (!isDraggingThumb) return;
        const topMargin = 30;
        const bottomMargin = 30;
        const detailsBoxRect = detailsBox.getBoundingClientRect();
        const trackHeight = detailsBoxRect.height - (topMargin + bottomMargin);
        const contentHeight = detailsContent.scrollHeight;
        const visibleHeight = detailsContent.clientHeight;

        const deltaY = e.clientY - dragStartY;
        const thumbHeight = parseFloat(customThumb.style.height);
        const thumbMaxY = trackHeight - thumbHeight;
        const scrollable = contentHeight - visibleHeight;
        const scrollRatio = scrollable / thumbMaxY;

        detailsContent.scrollTop = startScrollTop + deltaY * scrollRatio;
        updateScrollbar();
        showScrollbar();
    }

    function onThumbRelease() {
        isDraggingThumb = false;
        document.removeEventListener('mousemove', onThumbDrag);
        document.removeEventListener('mouseup', onThumbRelease);
        fadeOutScrollbarLater();
    }

    detailsBox.addEventListener('mousemove', (e) => {
        const detailsBoxRect = detailsBox.getBoundingClientRect();
        const distanceFromRight = detailsBoxRect.right - e.clientX;
        if (distanceFromRight < 30) {
            showScrollbar();
        } else {
            fadeOutScrollbarLater();
        }
    });

    function showScrollbar() {
        customScrollbar.style.opacity = '1';
        fadeOutScrollbarLater();
    }

    function fadeOutScrollbarLater() {
        if (scrollbarFadeTimeout) clearTimeout(scrollbarFadeTimeout);
        scrollbarFadeTimeout = setTimeout(() => {
            if (!isDraggingThumb) {
                customScrollbar.style.opacity = '0';
            }
        }, 1500);
    }

    customScrollbar.style.opacity = '0';

    // Detect if the device is touch-capable
    const isTouchDevice = ('ontouchstart' in window || navigator.maxTouchPoints > 0);

    // If it's a touch device, disable custom scrollbar and revert to native scrollbar
    if (isTouchDevice) {
        // Hide the custom scrollbar entirely
        customScrollbar.style.display = 'none';
        
        // Remove the "no visible scrollbar" styles so that native scrollbar can appear
        detailsContent.classList.add('touch-scrollbars');
        // Also ensure overflow is set to auto to allow native scrolling
        detailsContent.style.overflowY = 'auto';
    }

    // Handle hover circle for touch devices: add/remove 'active' on touchstart/touchend
    document.querySelectorAll('.menu-button, .hole-nav-button, .hole-label-button').forEach(btn => {
        btn.addEventListener('touchstart', () => {
            btn.classList.add('active');
        }, {passive: true});

        btn.addEventListener('touchend', () => {
            btn.classList.remove('active');
        }, {passive: true});

        btn.addEventListener('touchcancel', () => {
            btn.classList.remove('active');
        }, {passive: true});
    });

    // Handle hover circle for fullscreen button in details box
    if (fullscreenButton) {
        fullscreenButton.addEventListener('touchstart', () => {
            fullscreenButton.classList.add('active');
        }, {passive: true});

        fullscreenButton.addEventListener('touchend', () => {
            fullscreenButton.classList.remove('active');
        }, {passive: true});

        fullscreenButton.addEventListener('touchcancel', () => {
            fullscreenButton.classList.remove('active');
        }, {passive: true});
    }

    // Helper: record the first N ms of the camera path to a WebM file.
    // Usage from console: recordPathAnimation20s({ durationMs: 20000, fps: 30 })
    // Options: onBeforeRecord, onAfterRecord (callbacks for UI hide/restore)
    window.recordPathAnimation20s = function (options = {}) {
        const durationMs = options.durationMs || 20000;
        const fps = options.fps || 30;
        const onBeforeRecord = options.onBeforeRecord;
        const onAfterRecord = options.onAfterRecord;

        if (typeof MediaRecorder === 'undefined') {
            console.warn('MediaRecorder is not supported in this browser.');
            return;
        }
        if (!renderer || !renderer.domElement) {
            console.warn('Renderer or canvas not available.');
            return;
        }
        if (!pathAnimationState || !Array.isArray(pathAnimationState.checkpoints) || pathAnimationState.checkpoints.length < 2) {
            console.warn('Path animation requires at least 2 checkpoints.');
            return;
        }

        if (typeof onBeforeRecord === 'function') {
            onBeforeRecord();
        }

        if (!pathAnimationState.enabled && typeof setPathAnimationEnabled === 'function') {
            setPathAnimationEnabled(true);
        } else {
            pathAnimationState.enabled = true;
        }

        goToAnimationStart();

        const canvas = renderer.domElement;
        const stream = canvas.captureStream(fps);

        const preferredTypes = [
            'video/webm;codecs=vp9',
            'video/webm;codecs=vp8',
            'video/webm'
        ];
        let chosenType = '';
        if (typeof MediaRecorder.isTypeSupported === 'function') {
            for (const type of preferredTypes) {
                if (MediaRecorder.isTypeSupported(type)) {
                    chosenType = type;
                    break;
                }
            }
        }

        const recorder = chosenType
            ? new MediaRecorder(stream, { mimeType: chosenType })
            : new MediaRecorder(stream);

        const chunks = [];
        recorder.ondataavailable = (event) => {
            if (event.data && event.data.size > 0) {
                chunks.push(event.data);
            }
        };

        recorder.onstop = () => {
            const blob = new Blob(chunks, { type: recorder.mimeType || 'video/webm' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            const seconds = Math.round(durationMs / 1000);
            const holeLabel = (getActiveHoleConfig && getActiveHoleConfig()) ? (getActiveHoleConfig().label || '').replace(/\s+/g, '-') : 'hole';
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            a.href = url;
            a.download = `copper-rock-${holeLabel}-${seconds}s-${timestamp}.webm`;
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 0);
            if (typeof onAfterRecord === 'function') {
                onAfterRecord();
            }
        };

        recorder.start();

        setTimeout(() => {
            recorder.stop();
            stream.getTracks().forEach((track) => track.stop());
            if (pathAnimationState && pathAnimationState.playing) {
                pathAnimationState.playing = false;
                if (typeof syncAnimationEditorFromState === 'function') {
                    syncAnimationEditorFromState();
                }
            }
        }, durationMs);
    };

    const recordButton = document.getElementById('recordButton');
    if (recordButton) {
        recordButton.setAttribute('aria-label', 'Record 20 seconds of path animation');
        recordButton.addEventListener('click', () => {
            if (document.body.classList.contains('recording-mode')) return;
            if (isDetailsOpen && typeof closeDetails === 'function') {
                closeDetails();
            }
            document.body.classList.add('recording-mode');
            recordPathAnimation20s({
                durationMs: 20000,
                fps: 30,
                onBeforeRecord: () => {},
                onAfterRecord: () => {
                    document.body.classList.remove('recording-mode');
                }
            });
        });
    }

    // Apply layout mode on load and on resize
    window.addEventListener('resize', applyLayoutMode);
    window.addEventListener('load', () => {
        applyLayoutMode();
        updateScrollbar();
    });

    // Initialize layout mode
    applyLayoutMode();
    
    </script>
</body>
</html>
